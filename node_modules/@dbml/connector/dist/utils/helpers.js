"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIntersection = getIntersection;
exports.getTableSchemaKey = getTableSchemaKey;
exports.mergeTables = mergeTables;
exports.mergeFieldDictionary = mergeFieldDictionary;
exports.mergeIndexDictionary = mergeIndexDictionary;
exports.mergeTableConstraintDictionary = mergeTableConstraintDictionary;
function getIntersection(firstList, secondList) {
    return firstList.filter((item) => secondList.includes(item));
}
function getTableSchemaKey(schemaName, tableName) {
    if (!tableName || !tableName.trim()) {
        throw new Error('Table name must be a non-empty string');
    }
    return schemaName ? `${schemaName}.${tableName}` : `${tableName}`;
}
function mergeTables(firstTableList, secondTable) {
    return firstTableList.concat(secondTable);
}
function mergeFieldDictionary(firstDict, secondDict) {
    const result = Object.assign({}, firstDict);
    Object.keys(secondDict).forEach((key) => {
        if (!result[key]) {
            result[key] = [];
        }
        result[key] = result[key].concat(secondDict[key]);
    });
    return result;
}
function mergeIndexDictionary(firstDict, secondDict) {
    const result = Object.assign({}, firstDict);
    Object.keys(secondDict).forEach((key) => {
        if (!result[key]) {
            result[key] = [];
        }
        result[key] = result[key].concat(secondDict[key]);
    });
    return result;
}
function mergeTableConstraintDictionary(firstDict, secondDict) {
    const result = Object.assign({}, firstDict);
    Object.keys(secondDict).forEach((key) => {
        if (!result[key]) {
            result[key] = {};
        }
        result[key] = secondDict[key];
    });
    return result;
}
