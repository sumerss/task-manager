"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSchema = exports.buildSchemaQuery = exports.parseConnectionString = exports.parseJdbcSchema = void 0;
// You cannot use the "=" inside database's schema name. It will be treated as a delimiter.
const SCHEMAS_DELIMITER = 'schemas=';
const haveSchemas = (str) => {
    return str.toLowerCase().includes(SCHEMAS_DELIMITER);
};
const getSchemasPart = (str) => {
    return str ? str.toLowerCase().split(SCHEMAS_DELIMITER)[1] : '';
};
const noSchemaResult = (connectionString) => ({
    connectionString,
    schemas: [],
});
const parseOdbcSchema = (connectionString) => {
    const connectionParts = connectionString.split(';');
    const schemasPart = connectionParts.find((part) => haveSchemas(part));
    return {
        connectionString: connectionParts.filter((part) => !haveSchemas(part)).join(';'),
        schemas: (0, exports.parseSchema)(getSchemasPart(schemasPart)),
    };
};
const parseJdbcSchema = (connectionString) => {
    const connectionParts = connectionString.split('?');
    const connectionArgs = connectionParts[1].split('&');
    const schemasPart = connectionArgs.find((part) => haveSchemas(part));
    return {
        connectionString: connectionParts[0],
        schemas: (0, exports.parseSchema)(getSchemasPart(schemasPart)),
    };
};
exports.parseJdbcSchema = parseJdbcSchema;
const parseConnectionString = (connectionString, connectionStringType) => {
    if (!haveSchemas(connectionString))
        return noSchemaResult(connectionString);
    return connectionStringType === 'jdbc'
        ? (0, exports.parseJdbcSchema)(connectionString)
        : parseOdbcSchema(connectionString);
};
exports.parseConnectionString = parseConnectionString;
const buildSchemaQuery = (columnName, schemas, prefix = 'AND') => {
    if (schemas.length === 0)
        return '';
    return `${prefix} ${columnName} IN (${schemas.map((schema) => `'${schema}'`).join(', ')})`;
};
exports.buildSchemaQuery = buildSchemaQuery;
// Inputs: schemas string -> Output: schema array string[]
// schema1, schema2 -> ['schema1', 'schema2']
// schema3,schema4 -> ['schema3", 'schema4']
// "schema5,gg", "schema6", schema7 -> ['schema5,gg', 'schema6', 'schema7']
// schema8 -> ['schema8']
const parseSchema = (schemas) => {
    if (!schemas)
        return [];
    const schemasWithDoubleQuotes = schemas.split(/,(?=(?:[^"]*(?:"[^"]*")*)*$)/).map((s) => s.trim());
    return schemasWithDoubleQuotes.map((s) => s.replace(/"/g, ''));
};
exports.parseSchema = parseSchema;
