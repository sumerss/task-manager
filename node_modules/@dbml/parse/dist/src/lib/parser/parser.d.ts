import { CompileError } from '../errors';
import { SyntaxToken } from '../lexer/tokens';
import { default as Report } from '../report';
import { ProgramNode, SyntaxNodeIdGenerator } from './nodes';
export default class Parser {
    private tokens;
    private current;
    private errors;
    private contextStack;
    private nodeFactory;
    constructor(tokens: SyntaxToken[], nodeIdGenerator: SyntaxNodeIdGenerator);
    private isAtEnd;
    private advance;
    private peek;
    private match;
    private check;
    private previous;
    private canHandle;
    private consume;
    private discardUntil;
    private gatherInvalid;
    parse(): Report<{
        ast: ProgramNode;
        tokens: SyntaxToken[];
    }, CompileError>;
    private program;
    private synchronizeProgram;
    private elementDeclaration;
    private synchronizeElementDeclarationName;
    private synchronizeElementDeclarationAlias;
    private fieldDeclaration;
    private expression;
    private shouldStopExpression;
    private normalExpression;
    private expression_bp;
    private leftExpression_bp;
    private extractOperand;
    private functionExpression;
    private variable;
    private blockExpression;
    private canBeField;
    private synchronizeBlock;
    private primaryExpression;
    private tupleExpression;
    private synchronizeTuple;
    private listExpression;
    private synchronizeList;
    private attribute;
    private synchronizeAttributeName;
    private attributeValue;
    private synchronizeAttributeValue;
    private attributeName;
    private logError;
}
