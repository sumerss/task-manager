import { SyntaxToken } from '../lexer/tokens';
import { NodeSymbol } from '../analyzer/symbol/symbols';
import { Position } from '../types';
export type SyntaxNodeId = number;
export declare class SyntaxNodeIdGenerator {
    private id;
    reset(): void;
    nextId(): SyntaxNodeId;
}
export declare class SyntaxNode {
    id: Readonly<SyntaxNodeId>;
    kind: SyntaxNodeKind;
    startPos: Readonly<Position>;
    start: Readonly<number>;
    fullStart: Readonly<number>;
    endPos: Readonly<Position>;
    end: Readonly<number>;
    fullEnd: Readonly<number>;
    symbol?: NodeSymbol;
    referee?: NodeSymbol;
    constructor(id: SyntaxNodeId, kind: SyntaxNodeKind, args: Readonly<SyntaxToken | SyntaxNode | undefined>[]);
}
export declare enum SyntaxNodeKind {
    PROGRAM = "<program>",
    ELEMENT_DECLARATION = "<element-declaration>",
    ATTRIBUTE = "<attribute>",
    IDENTIFIER_STREAM = "<identifer-stream>",
    LITERAL = "<literal>",
    VARIABLE = "<variable>",
    PREFIX_EXPRESSION = "<prefix-expression>",
    INFIX_EXPRESSION = "<infix-expression>",
    POSTFIX_EXPRESSION = "<postfix-expression>",
    FUNCTION_EXPRESSION = "<function-expression>",
    FUNCTION_APPLICATION = "<function-application>",
    BLOCK_EXPRESSION = "<block-expression>",
    LIST_EXPRESSION = "<list-expression>",
    TUPLE_EXPRESSION = "<tuple-expression>",
    CALL_EXPRESSION = "<call-expression>",
    PRIMARY_EXPRESSION = "<primary-expression>",
    GROUP_EXPRESSION = "<group-expression>",
    DUMMY = "<dummy>",
    ARRAY = "<array>",
    PARTIAL_INJECTION = "<partial-injection>"
}
export declare class ProgramNode extends SyntaxNode {
    body: ElementDeclarationNode[];
    eof?: SyntaxToken;
    constructor({ body, eof }: {
        body?: ElementDeclarationNode[];
        eof?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class ElementDeclarationNode extends SyntaxNode {
    type?: SyntaxToken;
    name?: NormalExpressionNode;
    as?: SyntaxToken;
    alias?: NormalExpressionNode;
    attributeList?: ListExpressionNode;
    bodyColon?: SyntaxToken;
    parent?: ElementDeclarationNode | ProgramNode;
    body?: FunctionApplicationNode | BlockExpressionNode;
    constructor({ type, name, as, alias, attributeList, bodyColon, body, }: {
        type?: SyntaxToken;
        name?: NormalExpressionNode;
        as?: SyntaxToken;
        alias?: NormalExpressionNode;
        attributeList?: ListExpressionNode;
        bodyColon?: SyntaxToken;
        body?: BlockExpressionNode | FunctionApplicationNode;
    }, id: SyntaxNodeId);
}
export declare class IdentiferStreamNode extends SyntaxNode {
    identifiers: SyntaxToken[];
    constructor({ identifiers }: {
        identifiers?: SyntaxToken[];
    }, id: SyntaxNodeId);
}
export declare class AttributeNode extends SyntaxNode {
    name?: IdentiferStreamNode | PrimaryExpressionNode;
    colon?: SyntaxToken;
    value?: NormalExpressionNode | IdentiferStreamNode;
    constructor({ name, colon, value, }: {
        name?: IdentiferStreamNode | PrimaryExpressionNode;
        colon?: SyntaxToken;
        value?: NormalExpressionNode | IdentiferStreamNode;
    }, id: SyntaxNodeId);
}
export type NormalExpressionNode = PrefixExpressionNode | InfixExpressionNode | PostfixExpressionNode | BlockExpressionNode | ListExpressionNode | TupleExpressionNode | CallExpressionNode | PrimaryExpressionNode | FunctionExpressionNode | DummyNode | ArrayNode;
export type ExpressionNode = ElementDeclarationNode | NormalExpressionNode | FunctionApplicationNode;
export declare class PrefixExpressionNode extends SyntaxNode {
    op?: SyntaxToken;
    expression?: NormalExpressionNode;
    constructor({ op, expression }: {
        op?: SyntaxToken;
        expression?: NormalExpressionNode;
    }, id: SyntaxNodeId);
}
export declare class InfixExpressionNode extends SyntaxNode {
    op?: SyntaxToken;
    leftExpression?: NormalExpressionNode;
    rightExpression?: NormalExpressionNode;
    constructor({ op, leftExpression, rightExpression, }: {
        op?: SyntaxToken;
        leftExpression?: NormalExpressionNode;
        rightExpression?: NormalExpressionNode;
    }, id: SyntaxNodeId);
}
export declare class PostfixExpressionNode extends SyntaxNode {
    op?: SyntaxToken;
    expression?: NormalExpressionNode;
    constructor({ op, expression }: {
        op?: SyntaxToken;
        expression?: NormalExpressionNode;
    }, id: SyntaxNodeId);
}
export declare class FunctionExpressionNode extends SyntaxNode {
    value?: SyntaxToken;
    constructor({ value }: {
        value?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class FunctionApplicationNode extends SyntaxNode {
    callee?: ExpressionNode;
    args: ExpressionNode[];
    constructor({ callee, args }: {
        callee?: ExpressionNode;
        args?: ExpressionNode[];
    }, id: SyntaxNodeId);
}
export declare class BlockExpressionNode extends SyntaxNode {
    blockOpenBrace?: SyntaxToken;
    body: (PartialInjectionNode | ElementDeclarationNode | FunctionApplicationNode)[];
    blockCloseBrace?: SyntaxToken;
    constructor({ blockOpenBrace, body, blockCloseBrace, }: {
        blockOpenBrace?: SyntaxToken;
        body?: (PartialInjectionNode | ElementDeclarationNode | FunctionApplicationNode)[];
        blockCloseBrace?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class PartialInjectionNode extends SyntaxNode {
    partial?: VariableNode;
    constructor({ op, partial }: {
        op?: SyntaxToken;
        partial?: VariableNode;
    }, id: SyntaxNodeId);
}
export declare class ListExpressionNode extends SyntaxNode {
    listOpenBracket?: SyntaxToken;
    elementList: AttributeNode[];
    commaList: SyntaxToken[];
    listCloseBracket?: SyntaxToken;
    constructor({ listOpenBracket, elementList, commaList, listCloseBracket, }: {
        listOpenBracket?: SyntaxToken;
        elementList?: AttributeNode[];
        commaList?: SyntaxToken[];
        listCloseBracket?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class TupleExpressionNode extends SyntaxNode {
    tupleOpenParen?: SyntaxToken;
    elementList: NormalExpressionNode[];
    commaList: SyntaxToken[];
    tupleCloseParen?: SyntaxToken;
    constructor({ tupleOpenParen, elementList, commaList, tupleCloseParen, }: {
        tupleOpenParen?: SyntaxToken;
        elementList?: NormalExpressionNode[];
        commaList?: SyntaxToken[];
        tupleCloseParen?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class GroupExpressionNode extends TupleExpressionNode {
    constructor({ groupOpenParen, expression, groupCloseParen, }: {
        groupOpenParen?: SyntaxToken;
        expression?: NormalExpressionNode;
        groupCloseParen?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class CallExpressionNode extends SyntaxNode {
    callee?: NormalExpressionNode;
    argumentList?: TupleExpressionNode;
    constructor({ callee, argumentList, }: {
        callee?: NormalExpressionNode;
        argumentList?: TupleExpressionNode;
    }, id: SyntaxNodeId);
}
export declare class LiteralNode extends SyntaxNode {
    literal?: SyntaxToken;
    constructor({ literal }: {
        literal?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class VariableNode extends SyntaxNode {
    variable?: SyntaxToken;
    constructor({ variable }: {
        variable?: SyntaxToken;
    }, id: SyntaxNodeId);
}
export declare class PrimaryExpressionNode extends SyntaxNode {
    expression?: LiteralNode | VariableNode;
    constructor({ expression }: {
        expression?: LiteralNode | VariableNode;
    }, id: SyntaxNodeId);
}
export declare class DummyNode extends SyntaxNode {
    constructor({ pre }: {
        pre: Readonly<SyntaxNode> | Readonly<SyntaxToken>;
    }, id: SyntaxNodeId);
}
export declare class ArrayNode extends SyntaxNode {
    array?: NormalExpressionNode;
    indexer?: ListExpressionNode;
    constructor({ expression, indexer }: {
        expression?: NormalExpressionNode;
        indexer: ListExpressionNode;
    }, id: SyntaxNodeId);
}
