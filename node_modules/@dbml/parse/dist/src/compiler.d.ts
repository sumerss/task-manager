import { SymbolKind } from './lib/analyzer/symbol/symbolIndex';
import { default as SymbolTable } from './lib/analyzer/symbol/symbolTable';
import { CompileError } from './lib/errors';
import { ElementDeclarationNode, ProgramNode, SyntaxNode } from './lib/parser/nodes';
import { NodeSymbol } from './lib/analyzer/symbol/symbols';
import { default as Report } from './lib/report';
import { SyntaxToken } from './lib/lexer/tokens';
import { Database } from './lib/interpreter/types';
import { DBMLCompletionItemProvider, DBMLDefinitionProvider, DBMLReferencesProvider } from './services/index';
export declare const enum ScopeKind {
    TABLE = 0,
    ENUM = 1,
    TABLEGROUP = 2,
    INDEXES = 3,
    NOTE = 4,
    REF = 5,
    PROJECT = 6,
    CUSTOM = 7,
    TOPLEVEL = 8,
    TABLEPARTIAL = 9
}
export default class Compiler {
    private source;
    private cache;
    private nodeIdGenerator;
    private symbolIdGenerator;
    private createQuery;
    setSource(source: string): void;
    readonly token: {
        invalidStream: () => readonly SyntaxToken[];
        flatStream: () => readonly SyntaxToken[];
    };
    readonly parse: {
        source: () => string;
        _: () => Report<Readonly<{
            ast: ProgramNode;
            tokens: SyntaxToken[];
            rawDb?: Database | undefined;
        }>, CompileError>;
        ast: () => Readonly<ProgramNode>;
        errors: () => readonly Readonly<CompileError>[];
        tokens: () => Readonly<SyntaxToken>[];
        rawDb: () => Readonly<Database> | undefined;
        publicSymbolTable: () => Readonly<SymbolTable>;
    };
    readonly container: {
        stack: (arg: number) => readonly Readonly<SyntaxNode>[];
        token: (arg: number) => {
            token: SyntaxToken;
            index: number;
        } | {
            token: undefined;
            index: undefined;
        };
        element: (arg: number) => Readonly<ProgramNode | ElementDeclarationNode>;
        scope: (arg: number) => Readonly<SymbolTable> | undefined;
        scopeKind: (arg: number) => ScopeKind;
    };
    readonly symbol: {
        ofName: (arg: {
            nameStack: string[];
            owner: ProgramNode | ElementDeclarationNode;
        }) => readonly Readonly<{
            symbol: NodeSymbol;
            kind: SymbolKind;
            name: string;
        }>[];
        members: (arg: NodeSymbol) => readonly Readonly<{
            symbol: NodeSymbol;
            kind: SymbolKind;
            name: string;
        }>[];
    };
    initMonacoServices(): {
        definitionProvider: DBMLDefinitionProvider;
        referenceProvider: DBMLReferencesProvider;
        autocompletionProvider: DBMLCompletionItemProvider;
    };
}
