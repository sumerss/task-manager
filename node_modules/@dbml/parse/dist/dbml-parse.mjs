import g, { last as Ve, forIn as Ge, partition as Pt, head as ln, findLastIndex as cn } from "lodash";
var u = /* @__PURE__ */ ((t) => (t.SPACE = "<space>", t.TAB = "<tab>", t.NEWLINE = "<newline>", t.COMMA = "<comma>", t.LPAREN = "<lparen>", t.RPAREN = "<rparen>", t.LBRACE = "<lbrace>", t.RBRACE = "<rbrace>", t.LBRACKET = "<lbracket>", t.RBRACKET = "<rbracket>", t.LANGLE = "<langle>", t.RANGLE = "<rangle>", t.OP = "<op>", t.EOF = "<eof>", t.NUMERIC_LITERAL = "<number>", t.STRING_LITERAL = "<string>", t.COLOR_LITERAL = "<color>", t.FUNCTION_EXPRESSION = "<function-expression>", t.QUOTED_STRING = "<variable>", t.IDENTIFIER = "<identifier>", t.SEMICOLON = "<semicolon>", t.COLON = "<colon>", t.TILDE = "<tilde>", t.SINGLE_LINE_COMMENT = "<single-line-comment>", t.MULTILINE_COMMENT = "<multiline-comment>", t))(u || {});
function un(t) {
  switch (t.kind) {
    case "<newline>":
    case "<space>":
    case "<tab>":
    case "<single-line-comment>":
    case "<multiline-comment>":
      return !0;
    default:
      return !1;
  }
}
function hn(t) {
  if (!t)
    return !1;
  switch (t) {
    case "+":
    case "-":
    case "*":
    case "/":
    case "%":
    case "<":
    case ">":
    case "=":
    case "!":
    case ".":
    case "&":
    case "|":
      return !0;
    default:
      return !1;
  }
}
function Et(t) {
  return t !== void 0 && t.kind === "<op>";
}
class Q {
  constructor(e, n, s, i, a) {
    this.kind = e, this.startPos = n, this.endPos = s, this.value = i, this.leadingTrivia = [], this.trailingTrivia = [], this.leadingInvalid = [], this.trailingInvalid = [], this.isInvalid = a, this.start = n.offset, this.end = s.offset;
  }
  static create(e, n, s, i, a) {
    return new Q(e, n, s, i, a);
  }
}
function St(t) {
  return t.trailingTrivia.find(({ kind: e }) => e === u.NEWLINE) !== void 0;
}
function Nt(t, e) {
  return e.leadingTrivia.find(({ kind: s }) => s === u.NEWLINE) !== void 0 || St(t);
}
function Ze(t) {
  return t.trailingTrivia.find(({ kind: e }) => [u.SPACE, u.TAB].includes(e)) !== void 0;
}
function Dt(t) {
  return t.trailingTrivia.length === 0 ? t.end : Dt(Ve(t.trailingTrivia));
}
function xt(t) {
  return t.leadingTrivia.length === 0 ? t.start : xt(t.leadingTrivia[0]);
}
function fn(t) {
  return [u.SINGLE_LINE_COMMENT, u.MULTILINE_COMMENT].includes(
    t.kind
  );
}
class pn {
  constructor() {
    this.id = 0;
  }
  reset() {
    this.id = 0;
  }
  nextId() {
    return this.id++;
  }
}
class x {
  // The symbol that this syntax node refers to
  // args must be passed in order of appearance in the node
  constructor(e, n, s) {
    this.id = e, this.kind = n;
    const i = s.find((r) => r !== void 0 && !Number.isNaN(r.start));
    i ? (this.startPos = i.startPos, this.fullStart = i instanceof Q ? xt(i) : i.fullStart) : (this.startPos = {
      offset: NaN,
      column: NaN,
      line: NaN
    }, this.fullStart = NaN);
    const a = [...s].reverse().find((r) => r !== void 0 && !Number.isNaN(r.end));
    a ? (this.endPos = a.endPos, this.fullEnd = a instanceof Q ? Dt(a) : a.fullEnd) : (this.endPos = {
      offset: NaN,
      column: NaN,
      line: NaN
    }, this.fullEnd = NaN), this.start = this.startPos.offset, this.end = this.endPos.offset;
  }
}
var me = /* @__PURE__ */ ((t) => (t.PROGRAM = "<program>", t.ELEMENT_DECLARATION = "<element-declaration>", t.ATTRIBUTE = "<attribute>", t.IDENTIFIER_STREAM = "<identifer-stream>", t.LITERAL = "<literal>", t.VARIABLE = "<variable>", t.PREFIX_EXPRESSION = "<prefix-expression>", t.INFIX_EXPRESSION = "<infix-expression>", t.POSTFIX_EXPRESSION = "<postfix-expression>", t.FUNCTION_EXPRESSION = "<function-expression>", t.FUNCTION_APPLICATION = "<function-application>", t.BLOCK_EXPRESSION = "<block-expression>", t.LIST_EXPRESSION = "<list-expression>", t.TUPLE_EXPRESSION = "<tuple-expression>", t.CALL_EXPRESSION = "<call-expression>", t.PRIMARY_EXPRESSION = "<primary-expression>", t.GROUP_EXPRESSION = "<group-expression>", t.DUMMY = "<dummy>", t.ARRAY = "<array>", t.PARTIAL_INJECTION = "<partial-injection>", t))(me || {});
class K extends x {
  constructor({ body: e = [], eof: n }, s) {
    super(s, "<program>", [...e, n]), this.body = e, this.eof = n;
  }
}
class y extends x {
  constructor({
    type: e,
    name: n,
    as: s,
    alias: i,
    attributeList: a,
    bodyColon: r,
    body: c
  }, f) {
    if (super(f, "<element-declaration>", [
      e,
      n,
      s,
      i,
      a,
      r,
      c
    ]), c && r && !(c instanceof w || c instanceof y))
      throw new Error("If an element has a simple body, it must be a function application node");
    this.type = e, this.name = n, this.as = s, this.alias = i, this.attributeList = a, this.bodyColon = r, this.body = c;
  }
}
class ne extends x {
  constructor({ identifiers: e = [] }, n) {
    super(n, "<identifer-stream>", e || []), this.identifiers = e;
  }
}
class se extends x {
  constructor({
    name: e,
    colon: n,
    value: s
  }, i) {
    super(i, "<attribute>", [e, n, s]), this.name = e, this.value = s, this.colon = n;
  }
}
class Z extends x {
  constructor({ op: e, expression: n }, s) {
    super(s, "<prefix-expression>", [e, n]), this.op = e, this.expression = n;
  }
}
class le extends x {
  constructor({
    op: e,
    leftExpression: n,
    rightExpression: s
  }, i) {
    super(i, "<infix-expression>", [n, e, s]), this.op = e, this.leftExpression = n, this.rightExpression = s;
  }
}
class qe extends x {
  constructor({ op: e, expression: n }, s) {
    super(s, "<postfix-expression>", [n, e]), this.op = e, this.expression = n;
  }
}
class ue extends x {
  constructor({ value: e }, n) {
    super(n, "<function-expression>", [e]), this.value = e;
  }
}
class w extends x {
  constructor({ callee: e, args: n = [] }, s) {
    super(s, "<function-application>", [e, ...n]), this.callee = e, this.args = n;
  }
}
class oe extends x {
  constructor({
    blockOpenBrace: e,
    body: n = [],
    blockCloseBrace: s
  }, i) {
    super(i, "<block-expression>", [e, ...n, s]), this.blockOpenBrace = e, this.body = n, this.blockCloseBrace = s;
  }
}
class be extends x {
  constructor({ op: e, partial: n }, s) {
    super(s, "<partial-injection>", [e, n]), this.partial = n;
  }
}
class M extends x {
  constructor({
    listOpenBracket: e,
    elementList: n = [],
    commaList: s = [],
    listCloseBracket: i
  }, a) {
    super(a, "<list-expression>", [
      e,
      ...Ot(n, s),
      i
    ]), this.listOpenBracket = e, this.elementList = n, this.commaList = s, this.listCloseBracket = i;
  }
}
class ce extends x {
  constructor({
    tupleOpenParen: e,
    elementList: n = [],
    commaList: s = [],
    tupleCloseParen: i
  }, a) {
    super(a, "<tuple-expression>", [
      e,
      ...Ot(n, s),
      i
    ]), this.tupleOpenParen = e, this.elementList = n, this.commaList = s, this.tupleCloseParen = i;
  }
}
class nt extends ce {
  constructor({
    groupOpenParen: e,
    expression: n,
    groupCloseParen: s
  }, i) {
    super(
      {
        tupleOpenParen: e,
        elementList: n && [n],
        commaList: [],
        tupleCloseParen: s
      },
      i
    ), this.kind = "<group-expression>";
  }
}
class ee extends x {
  constructor({
    callee: e,
    argumentList: n
  }, s) {
    super(s, "<call-expression>", [e, n]), this.callee = e, this.argumentList = n;
  }
}
class ye extends x {
  constructor({ literal: e }, n) {
    super(n, "<literal>", [e]), this.literal = e;
  }
}
class re extends x {
  constructor({ variable: e }, n) {
    super(n, "<variable>", [e]), this.variable = e;
  }
}
class j extends x {
  constructor({ expression: e }, n) {
    super(n, "<primary-expression>", [e]), this.expression = e;
  }
}
class Me extends x {
  constructor({ pre: e }, n) {
    const s = Q.create(u.SPACE, e.endPos, e.endPos, " ", !1);
    super(n, "<dummy>", [s]);
  }
}
class Ie extends x {
  constructor({ expression: e, indexer: n }, s) {
    super(s, "<array>", [e, n]), this.array = e, this.indexer = n;
  }
}
function Ot(t, e) {
  if (!t || t.length === 0)
    return e || [];
  if (!e || e.length === 0)
    return t || [];
  const [n] = t, [s] = e;
  return (n.start < s.start ? g.flatten(g.zip(t, e)) : g.flatten(g.zip(e, t))).filter(
    (i) => i !== null
  );
}
function Ss(t, e = !1) {
  return JSON.stringify(
    t,
    function(n, s) {
      var i;
      return !(this instanceof K) && n === "symbol" ? s == null ? void 0 : s.id : (
        /* this instanceof SyntaxNode && */
        n === "symbol" ? {
          symbolTable: s == null ? void 0 : s.symbolTable,
          id: s == null ? void 0 : s.id,
          references: s == null ? void 0 : s.references.map((a) => a.id),
          declaration: (i = s == null ? void 0 : s.declaration) == null ? void 0 : i.id
        } : (
          /* this instanceof SyntaxNode && */
          n === "referee" || /* this instanceof SyntaxNode && */
          n === "parent" || /* this instanceof NodeSymbol && */
          n === "declaration" ? s == null ? void 0 : s.id : (
            /* this instanceof NodeSymbol && */
            n === "symbolTable" ? Object.fromEntries(s.table) : s
          )
        )
      );
    },
    e ? 2 : 0
  );
}
class U {
  constructor(e) {
    this.value = e;
  }
  unwrap() {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrap_or(e) {
    return this.value;
  }
  and_then(e) {
    return e(this.value);
  }
  map(e) {
    return new U(e(this.value));
  }
  isOk() {
    return !0;
  }
}
class P {
  constructor() {
    this.value = void 0;
  }
  unwrap() {
    throw new Error("Trying to unwrap a None value");
  }
  unwrap_or(e) {
    return e;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  and_then(e) {
    return new P();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(e) {
    return new P();
  }
  // eslint-disable-next-line class-methods-use-this
  isOk() {
    return !1;
  }
}
var m = /* @__PURE__ */ ((t) => (t.Schema = "Schema", t.Table = "Table", t.Column = "Column", t.TableGroup = "TableGroup", t.TableGroupField = "TableGroup field", t.Enum = "Enum", t.EnumField = "Enum field", t.Note = "Note", t.TablePartial = "TablePartial", t.TablePartialInjection = "TablePartialInjection", t))(m || {});
function st(t) {
  return `Schema:${t}`;
}
function Ce(t) {
  return `Table:${t}`;
}
function He(t) {
  return `Column:${t}`;
}
function it(t) {
  return `Enum:${t}`;
}
function at(t) {
  return `Enum field:${t}`;
}
function rt(t) {
  return `TableGroup:${t}`;
}
function ot(t) {
  return `TableGroup field:${t}`;
}
function dn(t) {
  return `Note:${t}`;
}
function lt(t) {
  return `TablePartial:${t}`;
}
function Rt(t) {
  return `TablePartialInjection:${t}`;
}
function Fe(t, e) {
  switch (e) {
    case "Column":
      return He(t);
    case "Enum":
      return it(t);
    case "Enum field":
      return at(t);
    case "Schema":
      return st(t);
    case "Table":
      return Ce(t);
    case "TableGroup":
      return rt(t);
    case "TableGroup field":
      return ot(t);
    case "TablePartial":
      return lt(t);
    default:
      throw new Error("Unreachable");
  }
}
function ie(t) {
  const [e, n] = t.split(":");
  return Object.values(m).includes(e) ? new U({
    name: n,
    kind: e
  }) : new P();
}
function En(t) {
  const e = ie(t).unwrap_or(void 0);
  if (!e)
    return !1;
  const { kind: n, name: s } = e;
  return n === "Schema" && s === "public";
}
function Nn(t) {
  const e = ie(t).unwrap_or(void 0);
  if (!e) return !1;
  const { kind: n } = e;
  return n === "TablePartialInjection";
}
function Tn(t) {
  const e = ie(t).unwrap_or(void 0);
  if (!e) return null;
  const { kind: n, name: s } = e;
  return n === "TablePartialInjection" ? Fe(
    s,
    "TablePartial"
    /* TablePartial */
  ) : null;
}
class mn {
  constructor() {
    this.id = 0;
  }
  reset() {
    this.id = 0;
  }
  nextId() {
    return this.id++;
  }
}
class Ut {
  constructor({ symbolTable: e }, n) {
    this.references = [], this.id = n, this.symbolTable = e;
  }
}
class bn {
  constructor({ symbolTable: e, declaration: n }, s) {
    this.references = [], this.id = s, this.symbolTable = e, this.declaration = n;
  }
}
class In {
  constructor({ declaration: e }, n) {
    this.references = [], this.id = n, this.declaration = e;
  }
}
class Mt {
  constructor({ symbolTable: e, declaration: n }, s) {
    this.references = [], this.id = s, this.symbolTable = e, this.declaration = n;
  }
}
class ct {
  constructor({ declaration: e }, n) {
    this.references = [], this.id = n, this.declaration = e;
  }
}
class Ln {
  constructor({ symbolTable: e, declaration: n }, s) {
    this.references = [], this.id = s, this.symbolTable = e, this.declaration = n;
  }
}
class An {
  constructor({ declaration: e }, n) {
    this.references = [], this.id = n, this.declaration = e;
  }
}
class _n {
  constructor({ symbolTable: e, declaration: n }, s) {
    this.references = [], this.id = s, this.symbolTable = e, this.declaration = n;
  }
}
class gn {
  constructor({ declaration: e }, n) {
    this.references = [], this.id = n, this.declaration = e;
  }
}
class vn {
  constructor({ injectorFieldSymbol: e, injectorDeclaration: n }, s) {
    this.references = [], this.id = s, this.injectorDeclaration = n, this.injectorFieldSymbol = e;
  }
}
function wn(t) {
  return [
    st,
    Ce,
    it,
    rt,
    He,
    at,
    ot,
    lt,
    Rt
  ].map((e) => e(t));
}
function yn(t) {
  return t instanceof ct ? vn : null;
}
function ze(t) {
  return !!t.match(new RegExp("(\\p{L}|_|\\p{M})", "gu"));
}
function Xe(t) {
  const [e] = t;
  return e >= "0" && e <= "9";
}
function kn(t) {
  const [e] = t;
  return Xe(e) || ze(e) && e.toLowerCase() >= "a" && e.toLowerCase() <= "f";
}
function ve(t) {
  return ze(t) || Xe(t);
}
function Tt(t, e) {
  const n = [], s = Math.min(t.length, e.length);
  for (let i = 0; i < s; i += 1)
    n.push(t[i], e[i]);
  return n.push(...t.slice(s), ...e.slice(s)), n;
}
function Se(t, e) {
  return t >= e.start && t < e.end;
}
function Ft(t) {
  var e;
  return t instanceof Z ? `${(e = t.op) == null ? void 0 : e.value}${Ft(t.expression)}` : t.expression.literal.value;
}
function et(t) {
  var e;
  return t instanceof Z ? ((e = t.op) == null ? void 0 : e.value) === "-" ? -et(t.expression) : et(t.expression) : Number.parseFloat(t.expression.literal.value);
}
var o = /* @__PURE__ */ ((t) => (t[t.UNKNOWN_SYMBOL = 1e3] = "UNKNOWN_SYMBOL", t[t.UNEXPECTED_SYMBOL = 1001] = "UNEXPECTED_SYMBOL", t[t.UNEXPECTED_EOF = 1002] = "UNEXPECTED_EOF", t[t.UNEXPECTED_NEWLINE = 1003] = "UNEXPECTED_NEWLINE", t[t.UNKNOWN_TOKEN = 1004] = "UNKNOWN_TOKEN", t[t.UNEXPECTED_TOKEN = 1005] = "UNEXPECTED_TOKEN", t[t.UNEXPECTED_ELEMENT_DECLARATION = 1006] = "UNEXPECTED_ELEMENT_DECLARATION", t[t.MISSING_SPACES = 1007] = "MISSING_SPACES", t[t.UNKNOWN_PREFIX_OP = 1008] = "UNKNOWN_PREFIX_OP", t[t.INVALID_OPERAND = 1009] = "INVALID_OPERAND", t[t.EMPTY_ATTRIBUTE_NAME = 1010] = "EMPTY_ATTRIBUTE_NAME", t[t.INVALID_ESCAPE_SEQUENCE = 1011] = "INVALID_ESCAPE_SEQUENCE", t[t.INVALID_NAME = 3e3] = "INVALID_NAME", t[t.UNEXPECTED_NAME = 3001] = "UNEXPECTED_NAME", t[t.NAME_NOT_FOUND = 3002] = "NAME_NOT_FOUND", t[t.DUPLICATE_NAME = 3003] = "DUPLICATE_NAME", t[t.INVALID_ALIAS = 3004] = "INVALID_ALIAS", t[t.UNEXPECTED_ALIAS = 3005] = "UNEXPECTED_ALIAS", t[t.UNEXPECTED_SETTINGS = 3006] = "UNEXPECTED_SETTINGS", t[t.INVALID_SETTINGS = 3007] = "INVALID_SETTINGS", t[t.UNEXPECTED_SIMPLE_BODY = 3008] = "UNEXPECTED_SIMPLE_BODY", t[t.UNEXPECTED_COMPLEX_BODY = 3009] = "UNEXPECTED_COMPLEX_BODY", t[t.INVALID_TABLE_CONTEXT = 3010] = "INVALID_TABLE_CONTEXT", t[t.INVALID_TABLE_SETTING = 3011] = "INVALID_TABLE_SETTING", t[t.DUPLICATE_TABLE_SETTING = 3012] = "DUPLICATE_TABLE_SETTING", t[t.INVALID_TABLEGROUP_CONTEXT = 3013] = "INVALID_TABLEGROUP_CONTEXT", t[t.INVALID_TABLEGROUP_ELEMENT_NAME = 3014] = "INVALID_TABLEGROUP_ELEMENT_NAME", t[t.DUPLICATE_TABLEGROUP_ELEMENT_NAME = 3015] = "DUPLICATE_TABLEGROUP_ELEMENT_NAME", t[t.DUPLICATE_TABLEGROUP_FIELD_NAME = 3016] = "DUPLICATE_TABLEGROUP_FIELD_NAME", t[t.INVALID_TABLEGROUP_FIELD = 3017] = "INVALID_TABLEGROUP_FIELD", t[t.EMPTY_TABLE = 3018] = "EMPTY_TABLE", t[t.INVALID_COLUMN = 3019] = "INVALID_COLUMN", t[t.INVALID_COLUMN_NAME = 3020] = "INVALID_COLUMN_NAME", t[t.UNKNOWN_COLUMN_SETTING = 3021] = "UNKNOWN_COLUMN_SETTING", t[t.INVALID_COLUMN_TYPE = 3022] = "INVALID_COLUMN_TYPE", t[t.DUPLICATE_COLUMN_NAME = 3023] = "DUPLICATE_COLUMN_NAME", t[t.DUPLICATE_COLUMN_SETTING = 3024] = "DUPLICATE_COLUMN_SETTING", t[t.INVALID_COLUMN_SETTING_VALUE = 3025] = "INVALID_COLUMN_SETTING_VALUE", t[t.INVALID_ENUM_CONTEXT = 3026] = "INVALID_ENUM_CONTEXT", t[t.INVALID_ENUM_ELEMENT_NAME = 3027] = "INVALID_ENUM_ELEMENT_NAME", t[t.INVALID_ENUM_ELEMENT = 3028] = "INVALID_ENUM_ELEMENT", t[t.DUPLICATE_ENUM_ELEMENT_NAME = 3029] = "DUPLICATE_ENUM_ELEMENT_NAME", t[t.UNKNOWN_ENUM_ELEMENT_SETTING = 3030] = "UNKNOWN_ENUM_ELEMENT_SETTING", t[t.DUPLICATE_ENUM_ELEMENT_SETTING = 3031] = "DUPLICATE_ENUM_ELEMENT_SETTING", t[t.INVALID_ENUM_ELEMENT_SETTING = 3032] = "INVALID_ENUM_ELEMENT_SETTING", t[t.EMPTY_ENUM = 3033] = "EMPTY_ENUM", t[t.INVALID_REF_CONTEXT = 3034] = "INVALID_REF_CONTEXT", t[t.UNKNOWN_REF_SETTING = 3035] = "UNKNOWN_REF_SETTING", t[t.DUPLICATE_REF_SETTING = 3036] = "DUPLICATE_REF_SETTING", t[t.INVALID_REF_SETTING_VALUE = 3037] = "INVALID_REF_SETTING_VALUE", t[t.INVALID_REF_RELATIONSHIP = 3038] = "INVALID_REF_RELATIONSHIP", t[t.INVALID_REF_FIELD = 3039] = "INVALID_REF_FIELD", t[t.EMPTY_REF = 3040] = "EMPTY_REF", t[t.REF_REDEFINED = 3041] = "REF_REDEFINED", t[t.INVALID_NOTE_CONTEXT = 3042] = "INVALID_NOTE_CONTEXT", t[t.INVALID_NOTE = 3043] = "INVALID_NOTE", t[t.NOTE_REDEFINED = 3044] = "NOTE_REDEFINED", t[t.NOTE_CONTENT_REDEFINED = 3045] = "NOTE_CONTENT_REDEFINED", t[t.EMPTY_NOTE = 3046] = "EMPTY_NOTE", t[t.INVALID_INDEXES_CONTEXT = 3047] = "INVALID_INDEXES_CONTEXT", t[t.INVALID_INDEXES_FIELD = 3048] = "INVALID_INDEXES_FIELD", t[t.INVALID_INDEX = 3049] = "INVALID_INDEX", t[t.UNKNOWN_INDEX_SETTING = 3050] = "UNKNOWN_INDEX_SETTING", t[t.DUPLICATE_INDEX_SETTING = 3051] = "DUPLICATE_INDEX_SETTING", t[t.UNEXPECTED_INDEX_SETTING_VALUE = 3052] = "UNEXPECTED_INDEX_SETTING_VALUE", t[t.INVALID_INDEX_SETTING_VALUE = 3053] = "INVALID_INDEX_SETTING_VALUE", t[t.INVALID_PROJECT_CONTEXT = 3054] = "INVALID_PROJECT_CONTEXT", t[t.PROJECT_REDEFINED = 3055] = "PROJECT_REDEFINED", t[t.INVALID_PROJECT_FIELD = 3056] = "INVALID_PROJECT_FIELD", t[t.INVALID_CUSTOM_CONTEXT = 3057] = "INVALID_CUSTOM_CONTEXT", t[t.INVALID_CUSTOM_ELEMENT_VALUE = 3058] = "INVALID_CUSTOM_ELEMENT_VALUE", t[t.INVALID_ELEMENT_IN_SIMPLE_BODY = 3059] = "INVALID_ELEMENT_IN_SIMPLE_BODY", t[t.INVALID_TABLE_PARTIAL_CONTEXT = 3060] = "INVALID_TABLE_PARTIAL_CONTEXT", t[t.INVALID_TABLE_PARTIAL_ELEMENT_NAME = 3061] = "INVALID_TABLE_PARTIAL_ELEMENT_NAME", t[t.INVALID_TABLE_PARTIAL_SETTING = 3062] = "INVALID_TABLE_PARTIAL_SETTING", t[t.DUPLICATE_TABLE_PARTIAL_ELEMENT_NAME = 3063] = "DUPLICATE_TABLE_PARTIAL_ELEMENT_NAME", t[t.DUPLICATE_TABLE_PARTIAL_SETTING = 3064] = "DUPLICATE_TABLE_PARTIAL_SETTING", t[t.INVALID_TABLE_PARTIAL_INJECTION = 3065] = "INVALID_TABLE_PARTIAL_INJECTION", t[t.INVALID_TABLE_PARTIAL_INJECTION_OP = 3066] = "INVALID_TABLE_PARTIAL_INJECTION_OP", t[t.INVALID_TABLE_PARTIAL_INJECTION_NAME = 3067] = "INVALID_TABLE_PARTIAL_INJECTION_NAME", t[t.DUPLICATE_TABLE_PARTIAL_INJECTION_NAME = 3068] = "DUPLICATE_TABLE_PARTIAL_INJECTION_NAME", t[t.BINDING_ERROR = 4e3] = "BINDING_ERROR", t[t.UNSUPPORTED = 5e3] = "UNSUPPORTED", t[t.CIRCULAR_REF = 5001] = "CIRCULAR_REF", t[t.SAME_ENDPOINT = 5002] = "SAME_ENDPOINT", t[t.UNEQUAL_FIELDS_BINARY_REF = 5003] = "UNEQUAL_FIELDS_BINARY_REF", t[t.CONFLICTING_SETTING = 5004] = "CONFLICTING_SETTING", t[t.TABLE_REAPPEAR_IN_TABLEGROUP = 5005] = "TABLE_REAPPEAR_IN_TABLEGROUP", t))(o || {});
class l extends Error {
  constructor(e, n, s) {
    super(n), this.code = e, this.diagnostic = n, this.nodeOrToken = s, this.start = s.start, this.end = s.end, this.name = this.constructor.name, Object.setPrototypeOf(this, l.prototype);
  }
}
class J {
  constructor(e, n) {
    this.value = e, this.errors = n === void 0 ? [] : n;
  }
  getValue() {
    return this.value;
  }
  getErrors() {
    return this.errors;
  }
  chain(e) {
    const n = e(this.value), s = [...this.errors, ...n.errors];
    return new J(n.value, s);
  }
  map(e) {
    return new J(e(this.value), this.errors);
  }
}
function Pn(t, e, n) {
  if (!t || !Ne(t) || e.length === 0)
    return new P();
  const s = [...e], i = mt(t).unwrap(), a = s.pop();
  if (!(a instanceof oe))
    return new P();
  const r = g.last(s) instanceof M ? s.pop() : void 0;
  if (s.length === 3) {
    const c = mt(s[1]).value;
    return !c || !tt(c) ? new P() : new U(
      n.create(y, {
        type: i,
        name: s[0],
        as: c,
        alias: s[2],
        attributeList: r,
        body: a
      })
    );
  }
  return s.length === 1 ? new U(
    n.create(y, {
      type: i,
      name: s[0],
      attributeList: r,
      body: a
    })
  ) : s.length === 0 ? new U(
    n.create(y, {
      type: i,
      attributeList: r,
      body: a
    })
  ) : new P();
}
function tt(t) {
  return t.kind === u.IDENTIFIER && t.value === "as";
}
function b(t) {
  t && (t instanceof Q ? Sn(t) : Dn(t));
}
function Sn(t) {
  t.kind !== u.EOF && (t.isInvalid = !0);
}
function Dn(t) {
  if (t instanceof y)
    b(t.type), b(t.name), b(t.as), b(t.alias), b(t.bodyColon), b(t.attributeList), b(t.body);
  else if (t instanceof ne)
    t.identifiers.forEach(b);
  else if (t instanceof se)
    b(t.name), b(t.colon), b(t.value);
  else if (t instanceof Z)
    b(t.op), b(t.expression);
  else if (t instanceof le)
    b(t.leftExpression), b(t.op), b(t.rightExpression);
  else if (t instanceof qe)
    b(t.op), b(t.expression);
  else if (t instanceof oe)
    b(t.blockOpenBrace), t.body.forEach(b), b(t.blockCloseBrace);
  else if (t instanceof M)
    b(t.listOpenBracket), t.commaList.forEach(b), t.elementList.forEach(b), b(t.listCloseBracket);
  else if (t instanceof ce)
    b(t.tupleOpenParen), t.commaList.forEach(b), t.elementList.forEach(b), b(t.tupleCloseParen);
  else if (t instanceof ee)
    b(t.callee), b(t.argumentList);
  else if (t instanceof w)
    b(t.callee), t.args.forEach(b);
  else if (t instanceof j)
    b(t.expression);
  else if (t instanceof ue)
    b(t.value);
  else if (t instanceof re)
    b(t.variable);
  else if (t instanceof ye)
    b(t.literal);
  else throw t instanceof nt ? new Error("This case is handled by the TupleExpressionNode case") : new Error("Unreachable case in markInvalidNode");
}
function Bt(t) {
  return !!(t != null && t.isInvalid);
}
function C(...t) {
  return t.filter((e) => e !== void 0);
}
function xn(t) {
  if (t instanceof K)
    return C(...t.body, t.eof);
  if (t instanceof y)
    return C(
      t.type,
      t.name,
      t.as,
      t.alias,
      t.attributeList,
      t.bodyColon,
      t.body
    );
  if (t instanceof se)
    return C(t.name, t.colon, t.value);
  if (t instanceof ne)
    return t.identifiers;
  if (t instanceof ye)
    return t.literal ? [t.literal] : [];
  if (t instanceof re)
    return C(t.variable);
  if (t instanceof Z)
    return C(t.op, t.expression);
  if (t instanceof le)
    return C(t.leftExpression, t.op, t.rightExpression);
  if (t instanceof qe)
    return C(t.expression, t.op);
  if (t instanceof ue)
    return C(t.value);
  if (t instanceof w)
    return C(t.callee, ...t.args);
  if (t instanceof oe)
    return C(t.blockOpenBrace, ...t.body, t.blockCloseBrace);
  if (t instanceof M)
    return C(
      t.listOpenBracket,
      ...Tt(t.elementList, t.commaList),
      t.listCloseBracket
    );
  if (t instanceof ce)
    return C(
      t.tupleOpenParen,
      ...Tt(t.elementList, t.commaList),
      t.tupleCloseParen
    );
  if (t instanceof ee)
    return C(t.callee, t.argumentList);
  if (t instanceof j)
    return C(t.expression);
  if (t instanceof Ie)
    return C(
      t.array,
      t.indexer
    );
  if (t instanceof be) return C(t.partial);
  throw t instanceof nt ? new Error("This case is already handled by TupleExpressionNode") : new Error("Unreachable - no other possible cases");
}
function mt(t) {
  return $(t) ? new U(t.expression.variable) : new P();
}
function Y(t) {
  var e;
  return t instanceof j && (t.expression instanceof re && t.expression.variable instanceof Q && t.expression.variable.kind === u.QUOTED_STRING || t.expression instanceof ye && ((e = t.expression.literal) == null ? void 0 : e.kind) === u.STRING_LITERAL);
}
function $(t) {
  return t instanceof j && t.expression instanceof re && t.expression.variable instanceof Q;
}
function Ne(t) {
  var e;
  return t instanceof j && t.expression instanceof re && ((e = t.expression.variable) == null ? void 0 : e.kind) === u.IDENTIFIER;
}
function ut(t) {
  var e;
  return t instanceof le && t.leftExpression instanceof x && t.rightExpression instanceof x && ((e = t.op) == null ? void 0 : e.value) === ".";
}
function we(t) {
  if (t === void 0)
    return new P();
  const e = t.identifiers.map((n) => n.value).join(" ");
  return e === "" ? new P() : new U(e);
}
class On {
  // list of errors during lexing
  constructor(e) {
    this.start = {
      offset: 0,
      line: 0,
      column: 0
    }, this.current = {
      offset: 0,
      line: 0,
      column: 0
    }, this.tokens = [], this.errors = [], this.text = e;
  }
  isAtEnd() {
    return this.current.offset >= this.text.length;
  }
  advance() {
    const e = this.peek();
    return this.current = { ...this.current }, e === `
` ? (this.current.line += 1, this.current.column = 0) : this.current.column += 1, this.current.offset += 1, e;
  }
  peek(e = 0) {
    if (!(this.current.offset + e >= this.text.length))
      return this.text[this.current.offset + e];
  }
  // Check if the sequence ahead matches `sequence`
  check(e) {
    for (let n = 0; n < e.length; n += 1)
      if (e[n] !== this.peek(n))
        return !1;
    return !0;
  }
  // If the sequence ahead matches `sequence`, move `current` past `sequence`
  match(e) {
    return this.check(e) ? (e.split("").forEach(() => this.advance()), !0) : !1;
  }
  addToken(e, n = !1) {
    this.tokens.push(this.createToken(e, n));
  }
  createToken(e, n = !1) {
    return Q.create(
      e,
      this.start,
      this.current,
      this.text.substring(this.start.offset, this.current.offset),
      n
    );
  }
  lex() {
    return this.scanTokens(), this.tokens.push(Q.create(u.EOF, this.start, this.current, "", !1)), this.gatherTrivia(), this.gatherInvalid(), new J(this.tokens, this.errors);
  }
  scanTokens() {
    for (; !this.isAtEnd(); ) {
      const e = this.advance();
      switch (e) {
        case " ":
          this.addToken(u.SPACE);
          break;
        case "\r":
          break;
        case `
`:
          this.addToken(u.NEWLINE);
          break;
        case "	":
          this.addToken(u.TAB);
          break;
        case ",":
          this.addToken(u.COMMA);
          break;
        case "(":
          this.addToken(u.LPAREN);
          break;
        case ")":
          this.addToken(u.RPAREN);
          break;
        case "[":
          this.addToken(u.LBRACKET);
          break;
        case "]":
          this.addToken(u.RBRACKET);
          break;
        case "{":
          this.addToken(u.LBRACE);
          break;
        case "}":
          this.addToken(u.RBRACE);
          break;
        case ";":
          this.addToken(u.SEMICOLON);
          break;
        case ":":
          this.addToken(u.COLON);
          break;
        case "~":
          this.addToken(u.TILDE);
          break;
        case "'":
          this.match("''") ? this.multilineStringLiteral() : this.singleLineStringLiteral();
          break;
        case '"':
          this.quotedVariable();
          break;
        case "`":
          this.functionExpression();
          break;
        case "#":
          this.colorLiteral();
          break;
        case "/":
          this.match("/") ? this.singleLineComment() : this.match("*") ? this.multilineComment() : this.operator(e);
          break;
        default:
          if (hn(e)) {
            this.operator(e);
            break;
          }
          if (ze(e)) {
            this.identifier();
            break;
          }
          if (Xe(e)) {
            this.numericLiteralOrIdentifier();
            break;
          }
          this.addToken(u.OP, !0), this.errors.push(
            new l(
              o.UNKNOWN_SYMBOL,
              `Unexpected token '${e}'`,
              this.createToken(u.OP, !0)
            )
          );
          break;
      }
      this.start = { ...this.current };
    }
  }
  gatherTrivia() {
    let e = !0, n = [], s;
    const i = [];
    for (const a of this.tokens)
      un(a) ? (n.push(a), a.kind === u.NEWLINE && s && (s.trailingTrivia = n, e = !0, s = void 0, n = [])) : (e ? a.leadingTrivia = n : s.trailingTrivia = n, i.push(a), n = [], s = a, e = !1);
    this.tokens = i;
  }
  gatherInvalid() {
    let e;
    const n = [], s = [];
    for (e = 0; e < this.tokens.length && Bt(this.tokens[e]); e += 1)
      s.push(this.tokens[e]);
    let i = this.tokens[e];
    for (i.leadingInvalid = [...s, ...i.leadingInvalid]; e < this.tokens.length; e += 1) {
      const a = this.tokens[e];
      a.isInvalid ? i.trailingInvalid.push(a) : (i = a, n.push(a));
    }
    this.tokens = n;
  }
  // Consuming characters until the `stopSequence` is encountered
  consumeUntil(e, n, {
    allowNewline: s,
    // Whether newline is allowed
    allowEof: i,
    // Whether EOF is allowed
    raw: a,
    // Whether to interpret '\' as a backlash
    consumeStopSequence: r = !0
  }) {
    let c = "";
    for (; !this.isAtEnd() && (s || !this.check(`
`)) && !this.check(n); )
      this.peek() === "\\" && !a ? (this.advance(), c += this.escapedString()) : c += this.advance();
    if (this.isAtEnd() && !i) {
      const f = this.createToken(e, !0);
      this.tokens.push(f), this.errors.push(
        new l(o.UNEXPECTED_EOF, "EOF reached while parsing", f)
      );
      return;
    }
    if (this.check(`
`) && !s) {
      const f = this.createToken(e, !0);
      this.tokens.push(f), this.errors.push(
        new l(
          o.UNEXPECTED_NEWLINE,
          "Invalid newline encountered while parsing",
          f
        )
      );
      return;
    }
    r && this.match(n), this.tokens.push(Q.create(e, this.start, this.current, c, !1));
  }
  singleLineStringLiteral() {
    this.consumeUntil(u.STRING_LITERAL, "'", {
      allowNewline: !1,
      allowEof: !1,
      raw: !1
    });
  }
  multilineStringLiteral() {
    this.consumeUntil(u.STRING_LITERAL, "'''", {
      allowNewline: !0,
      allowEof: !1,
      raw: !1
    });
  }
  functionExpression() {
    this.consumeUntil(u.FUNCTION_EXPRESSION, "`", {
      allowNewline: !1,
      allowEof: !1,
      raw: !0
    });
  }
  quotedVariable() {
    this.consumeUntil(u.QUOTED_STRING, '"', {
      allowNewline: !1,
      allowEof: !1,
      raw: !1
    });
  }
  singleLineComment() {
    this.consumeUntil(u.SINGLE_LINE_COMMENT, `
`, {
      allowNewline: !0,
      allowEof: !0,
      raw: !0,
      consumeStopSequence: !1
    });
  }
  multilineComment() {
    this.consumeUntil(u.MULTILINE_COMMENT, "*/", {
      allowNewline: !0,
      allowEof: !1,
      raw: !0
    });
  }
  identifier() {
    for (; !this.isAtEnd() && ve(this.peek()); )
      this.advance();
    this.addToken(u.IDENTIFIER);
  }
  operator(e) {
    switch (e) {
      case "<":
        [">", "="].includes(this.peek()) && this.advance();
        break;
      case ">":
        this.peek() === "=" && this.advance();
        break;
      case "=":
        this.peek() === "=" && this.advance();
        break;
      case "!":
        this.peek() === "=" && this.advance();
        break;
    }
    this.addToken(u.OP);
  }
  // we accept identifiers starting with digits but must contain at least one char or underscore
  numericLiteralOrIdentifier() {
    let e = 0;
    if (this.isAtEnd())
      return this.addToken(u.NUMERIC_LITERAL);
    for (; !this.isAtEnd(); ) {
      const n = this.check(".");
      if (e += n ? 1 : 0, e > 1)
        break;
      if (!n && this.current.offset === this.text.length - 1)
        return this.advance(), this.addToken(u.NUMERIC_LITERAL);
      if (!n && !ve(this.peek()))
        return this.addToken(u.NUMERIC_LITERAL);
      if (!n && !Xe(this.peek()))
        break;
      this.advance();
    }
    if (e > 0) {
      for (; !this.isAtEnd() && (this.check(".") || ve(this.peek())); )
        this.advance();
      const n = this.createToken(u.NUMERIC_LITERAL, !0);
      this.tokens.push(n), this.errors.push(new l(o.UNKNOWN_TOKEN, "Invalid number", n));
    } else {
      for (; !this.isAtEnd() && ve(this.peek()); )
        this.advance();
      const n = this.createToken(u.IDENTIFIER, !1);
      this.tokens.push(n);
    }
  }
  colorLiteral() {
    for (; !this.isAtEnd() && ve(this.peek()); )
      this.advance();
    this.addToken(u.COLOR_LITERAL);
  }
  escapedString() {
    const e = { column: this.current.column - 1, offset: this.current.offset - 1, line: this.current.line };
    if (this.isAtEnd())
      return "\\";
    switch (this.advance()) {
      case "\r":
        return this.check(`
`) && this.advance(), "";
      case `
`:
        return "";
      case "t":
        return "	";
      case "n":
        return `
`;
      case "\\":
        return "\\";
      case "r":
        return "\r";
      case "'":
        return "'";
      case '"':
        return '"';
      case "0":
        return "\0";
      case "b":
        return "\b";
      case "v":
        return "\v";
      case "f":
        return "\f";
      case " ":
        return "\\ ";
      case "u": {
        let n = "";
        for (let s = 0; s <= 3; s += 1) {
          if (this.isAtEnd() || !ve(this.peek()))
            return this.errors.push(new l(o.INVALID_ESCAPE_SEQUENCE, `Invalid unicode escape sequence '\\u${n}', only unicode escape sequences of the form '\\uHHHH' where H is a hexadecimal number are allowed`, Q.create(u.STRING_LITERAL, e, this.current, `\\u${n}`, !0))), `\\u${n}`;
          n += this.advance();
        }
        return String.fromCharCode(parseInt(n, 16));
      }
      default:
        return this.text[this.current.offset - 1];
    }
  }
}
var Be = /* @__PURE__ */ ((t) => (t[t.ListExpression = 0] = "ListExpression", t[t.GroupExpression = 1] = "GroupExpression", t[t.BlockExpression = 2] = "BlockExpression", t))(Be || {});
class Rn {
  constructor() {
    this.stack = [], this.numberOfNestedLParens = 0, this.numberOfNestedLBrackets = 0, this.numberOfNestedLBraces = 0;
  }
  push(e) {
    this.stack.push(e), e === 0 && (this.numberOfNestedLBrackets += 1), e === 1 && (this.numberOfNestedLParens += 1), e === 2 && (this.numberOfNestedLBraces += 1);
  }
  pop() {
    const e = this.stack.pop();
    return e === 0 && (this.numberOfNestedLBrackets -= 1), e === 1 && (this.numberOfNestedLParens -= 1), e === 2 && (this.numberOfNestedLBraces -= 1), e;
  }
  top() {
    return g.last(this.stack);
  }
  isWithinGroupExpressionContext() {
    return this.numberOfNestedLParens > 0;
  }
  isWithinListExpressionContext() {
    return this.numberOfNestedLBrackets > 0;
  }
  isWithinBlockExpressionContext() {
    return this.numberOfNestedLBraces > 0;
  }
  // Call the passed in callback
  // with the guarantee that the passed in context will be pushed and popped properly
  // even in cases of exceptions
  withContextDo(e, n) {
    return () => {
      this.push(e);
      try {
        return n();
      } finally {
        this.pop();
      }
    };
  }
  // Return the type of the handler context currently in the context stack to handle `token`
  findHandlerContext(e, n) {
    if (!(this.numberOfNestedLBraces <= 0 && this.numberOfNestedLBrackets <= 0 && this.numberOfNestedLParens <= 0))
      for (let s = n; s < e.length - 1; s += 1)
        switch (e[s].kind) {
          case u.COMMA:
            if (this.isWithinGroupExpressionContext() || this.isWithinListExpressionContext())
              return [...this.stack].reverse().find(
                (a) => [
                  1,
                  0
                  /* ListExpression */
                ].includes(a)
              );
            break;
          case u.RPAREN:
            if (this.isWithinGroupExpressionContext())
              return 1;
            break;
          case u.RBRACE:
            if (this.isWithinBlockExpressionContext())
              return 2;
            break;
          case u.RBRACKET:
            if (this.isWithinListExpressionContext())
              return 0;
            break;
        }
  }
}
class Un {
  constructor(e) {
    this.generator = e;
  }
  create(e, n) {
    return new e(n, this.generator.nextId());
  }
}
class T {
  constructor(e, n, s) {
    this.token = e, this.partialNode = n, this.handlerContext = s;
  }
}
class Mn {
  constructor(e, n) {
    this.current = 0, this.errors = [], this.contextStack = new Rn(), this.synchronizeProgram = () => {
      const s = this.peek();
      s.kind !== u.EOF ? b(this.advance()) : (b(this.peek()), this.logError(s, o.UNEXPECTED_EOF, "Unexpected EOF"));
    }, this.synchronizeElementDeclarationName = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (tt(s) || this.check(u.COLON, u.LBRACE, u.LBRACKET))
          break;
        b(s), this.advance();
      }
    }, this.synchronizeElementDeclarationAlias = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(u.COLON, u.LBRACE, u.LBRACKET))
          break;
        b(s), this.advance();
      }
    }, this.blockExpression = this.contextStack.withContextDo(Be.BlockExpression, () => {
      const s = { body: [] }, i = () => this.nodeFactory.create(oe, s);
      try {
        this.consume("Expect an opening brace '{'", u.LBRACE), s.blockOpenBrace = this.previous();
      } catch (a) {
        if (!(a instanceof T))
          throw a;
        if (s.blockOpenBrace = a.partialNode, !this.canHandle(a))
          throw new T(a.token, i(), a.handlerContext);
        this.synchronizeBlock();
      }
      for (; !this.isAtEnd() && !this.check(u.RBRACE); )
        try {
          if (this.match(u.TILDE)) {
            const a = this.previous(), r = this.variable(), c = this.nodeFactory.create(be, { op: a, partial: r });
            s.body.push(c);
          } else
            s.body.push(this.canBeField() ? this.fieldDeclaration() : this.expression());
        } catch (a) {
          if (!(a instanceof T))
            throw a;
          if (s.body.push(a.partialNode), !this.canHandle(a))
            throw new T(a.token, i(), a.handlerContext);
          this.synchronizeBlock();
        }
      try {
        this.consume("Expect a closing brace '}'", u.RBRACE), s.blockCloseBrace = this.previous();
      } catch (a) {
        if (!(a instanceof T))
          throw a;
        if (s.blockCloseBrace = a.partialNode, !this.canHandle(a))
          throw new T(a.token, i(), a.handlerContext);
        this.synchronizeBlock();
      }
      return i();
    }), this.synchronizeBlock = () => {
      if (!this.check(u.RBRACE))
        for (b(this.advance()); !this.isAtEnd(); ) {
          const s = this.peek();
          if (this.check(u.RBRACE) || Nt(this.previous(), s))
            break;
          b(s), this.advance();
        }
    }, this.tupleExpression = this.contextStack.withContextDo(Be.GroupExpression, () => {
      const s = { elementList: [], commaList: [] }, i = () => this.nodeFactory.create(nt, {
        groupOpenParen: s.tupleOpenParen,
        groupCloseParen: s.tupleCloseParen,
        expression: s.elementList[0]
      }), a = () => this.nodeFactory.create(ce, s);
      try {
        this.consume("Expect an opening parenthesis '('", u.LPAREN), s.tupleOpenParen = this.previous();
      } catch (r) {
        if (!(r instanceof T))
          throw r;
        if (s.tupleOpenParen = r.partialNode, !this.canHandle(r))
          throw new T(r.token, a(), r.handlerContext);
        this.synchronizeTuple();
      }
      if (!this.isAtEnd() && !this.check(u.RPAREN))
        try {
          s.elementList.push(this.normalExpression());
        } catch (r) {
          if (!(r instanceof T))
            throw r;
          if (s.elementList.push(r.partialNode), !this.canHandle(r))
            throw new T(r.token, i(), r.handlerContext);
          this.synchronizeTuple();
        }
      for (; !this.isAtEnd() && !this.check(u.RPAREN); )
        try {
          this.consume("Expect a comma ','", u.COMMA), s.commaList.push(this.previous()), s.elementList.push(this.normalExpression());
        } catch (r) {
          if (!(r instanceof T))
            throw r;
          if (r.partialNode instanceof x && s.elementList.push(r.partialNode), !this.canHandle(r))
            throw new T(r.token, a(), r.handlerContext);
          this.synchronizeTuple();
        }
      try {
        this.consume("Expect a closing parenthesis ')'", u.RPAREN), s.tupleCloseParen = this.previous();
      } catch (r) {
        if (!(r instanceof T))
          throw r;
        if (s.tupleCloseParen = r.partialNode, !this.canHandle(r))
          throw new T(r.token, a(), r.handlerContext);
        this.synchronizeTuple();
      }
      return s.elementList.length === 1 ? i() : a();
    }), this.synchronizeTuple = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(u.RPAREN, u.COMMA))
          break;
        b(s), this.advance();
      }
    }, this.listExpression = this.contextStack.withContextDo(Be.ListExpression, () => {
      const s = { elementList: [], commaList: [] }, i = () => this.nodeFactory.create(M, s);
      try {
        this.consume("Expect an opening bracket '['", u.LBRACKET), s.listOpenBracket = this.previous();
      } catch (a) {
        if (!(a instanceof T))
          throw a;
        if (s.listOpenBracket = a.partialNode, !this.canHandle(a))
          throw new T(a.token, i(), a.handlerContext);
        this.synchronizeList();
      }
      if (!this.isAtEnd() && !this.check(u.RBRACKET))
        try {
          s.elementList.push(this.attribute());
        } catch (a) {
          if (!(a instanceof T))
            throw a;
          if (s.elementList.push(a.partialNode), !this.canHandle(a))
            throw new T(a.token, i(), a.handlerContext);
          this.synchronizeList();
        }
      for (; !this.isAtEnd() && !this.check(u.RBRACKET); )
        try {
          this.consume("Expect a comma ','", u.COMMA), s.commaList.push(this.previous()), s.elementList.push(this.attribute());
        } catch (a) {
          if (!(a instanceof T))
            throw a;
          if (a.partialNode instanceof x && s.elementList.push(a.partialNode), !this.canHandle(a))
            throw new T(a.token, i(), a.handlerContext);
          this.synchronizeList();
        }
      try {
        this.consume("Expect a closing bracket ']'", u.RBRACKET), s.listCloseBracket = this.previous();
      } catch (a) {
        if (!(a instanceof T))
          throw a;
        if (s.listCloseBracket = a.partialNode, !this.canHandle(a))
          throw new T(a.token, i(), a.handlerContext);
        this.synchronizeList();
      }
      return i();
    }), this.synchronizeList = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(u.COMMA, u.RBRACKET))
          break;
        b(s), this.advance();
      }
    }, this.synchronizeAttributeName = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(u.COMMA, u.RBRACKET, u.COLON))
          break;
        b(s), this.advance();
      }
    }, this.synchronizeAttributeValue = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(u.COMMA, u.RBRACKET))
          break;
        b(s), this.advance();
      }
    }, this.tokens = e, this.nodeFactory = new Un(n);
  }
  isAtEnd() {
    return this.current >= this.tokens.length || this.tokens[this.current].kind === u.EOF;
  }
  advance() {
    return this.isAtEnd() ? g.last(this.tokens) : this.tokens[this.current++];
  }
  peek(e = 0) {
    return e + this.current >= this.tokens.length ? g.last(this.tokens) : this.tokens[this.current + e];
  }
  match(...e) {
    const n = this.check(...e);
    return n && this.advance(), n;
  }
  check(...e) {
    const n = this.peek();
    return e.includes(n.kind);
  }
  previous() {
    return this.tokens[this.current - 1];
  }
  canHandle(e) {
    return e.handlerContext === void 0 || e.handlerContext === this.contextStack.top();
  }
  consume(e, ...n) {
    if (!this.match(...n))
      throw this.logError(this.peek(), o.UNEXPECTED_TOKEN, e), new T(
        this.peek(),
        void 0,
        this.contextStack.findHandlerContext(this.tokens, this.current)
      );
  }
  // Discard tokens until one of `kind` is found
  // If any tokens are discarded, the error message is logged
  // Return whether the token of one of the listed kinds are eventually reached
  discardUntil(e, ...n) {
    if (this.isAtEnd() || !this.check(...n)) {
      for (b(this.peek()), this.logError(this.advance(), o.UNEXPECTED_TOKEN, e); !this.isAtEnd() && !this.check(...n); )
        b(this.advance());
      return !this.isAtEnd();
    }
    return !0;
  }
  gatherInvalid() {
    const e = [], n = [];
    let s, i = 0;
    for (; i < this.tokens.length && this.tokens[i].isInvalid; i += 1)
      n.push(this.tokens[i]);
    for (s = this.tokens[i], s.leadingInvalid = n, e.push(s), i += 1; i < this.tokens.length; i += 1) {
      const a = this.tokens[i];
      a.isInvalid ? s.trailingInvalid.push(a) : (s = a, e.push(s));
    }
    this.tokens = e;
  }
  parse() {
    const e = this.program(), n = this.advance(), s = this.nodeFactory.create(K, { body: e, eof: n });
    return this.gatherInvalid(), new J({ ast: s, tokens: this.tokens }, this.errors);
  }
  /* Parsing and synchronizing ProgramNode */
  program() {
    const e = [];
    for (; !this.isAtEnd(); )
      try {
        const n = this.elementDeclaration();
        e.push(n);
      } catch (n) {
        if (!(n instanceof T))
          throw n;
        e.push(n.partialNode), this.synchronizeProgram();
      }
    return e;
  }
  /* Parsing and synchronizing top-level ElementDeclarationNode */
  elementDeclaration() {
    const e = {}, n = () => this.nodeFactory.create(y, e);
    try {
      this.consume("Expect an identifier", u.IDENTIFIER), e.type = this.previous();
    } catch (s) {
      throw s instanceof T ? (e.type = s.partialNode, new T(s.token, n(), s.handlerContext)) : s;
    }
    if (!this.check(u.COLON, u.LBRACE, u.LBRACKET))
      try {
        e.name = this.normalExpression();
      } catch (s) {
        if (!(s instanceof T))
          throw s;
        if (e.name = s.partialNode, !this.canHandle(s))
          throw new T(s.token, n(), s.handlerContext);
        this.synchronizeElementDeclarationName();
      }
    if (tt(this.peek()))
      if (e.as = this.advance(), this.check(u.COLON, u.LBRACE, u.LBRACKET))
        this.logError(this.peek(), o.UNEXPECTED_TOKEN, "Expect an alias");
      else
        try {
          e.alias = this.normalExpression();
        } catch (s) {
          if (!(s instanceof T))
            throw s;
          if (e.alias = s.partialNode, !this.canHandle(s))
            throw new T(s.token, n(), s.handlerContext);
          this.synchronizeElementDeclarationAlias();
        }
    try {
      e.attributeList = this.check(u.LBRACKET) ? this.listExpression() : void 0;
    } catch (s) {
      throw s instanceof T ? (e.attributeList = s.partialNode, new T(s.token, n(), s.handlerContext)) : s;
    }
    if (!this.discardUntil(
      "Expect an opening brace '{' or a colon ':'",
      u.LBRACE,
      u.COLON
    ))
      return n();
    try {
      if (this.match(u.COLON)) {
        e.bodyColon = this.previous();
        const s = this.expression();
        s instanceof y ? (b(s), this.logError(s, o.UNEXPECTED_ELEMENT_DECLARATION, "An element's simple body must not be an element declaration")) : e.body = s;
      } else
        e.body = this.blockExpression();
    } catch (s) {
      throw s instanceof T ? (e.body = s.partialNode, new T(s.token, n(), s.handlerContext)) : s;
    }
    return this.nodeFactory.create(y, e);
  }
  /* Parsing nested element declarations with simple body */
  // e.g
  // ```
  //  Table Users {
  //    Note: 'This is a note'  // fieldDeclaration() handles this
  //  }
  fieldDeclaration() {
    const e = {}, n = () => this.nodeFactory.create(y, e);
    try {
      this.consume("Expect an identifier", u.IDENTIFIER), e.type = this.previous();
    } catch (s) {
      throw s instanceof T ? (e.type = s.partialNode, new T(s.token, n(), s.handlerContext)) : s;
    }
    try {
      this.consume("Expect a colon ':'", u.COLON), e.bodyColon = this.previous();
    } catch (s) {
      throw s instanceof T ? (e.bodyColon = s.partialNode, new T(s.token, n(), s.handlerContext)) : s;
    }
    try {
      const s = this.expression();
      s instanceof y ? this.errors.push(new l(o.INVALID_ELEMENT_IN_SIMPLE_BODY, "Simple body cannot be an element declaration", s)) : e.body = s;
    } catch (s) {
      throw s instanceof T ? (e.body = s.partialNode, new T(s.token, n(), s.handlerContext)) : s;
    }
    return this.nodeFactory.create(y, e);
  }
  /* Parsing any ExpressionNode, including non-NormalExpression */
  expression() {
    const e = { args: [] }, n = () => Pn(e.callee, e.args, this.nodeFactory).unwrap_or(
      this.nodeFactory.create(w, e)
    );
    try {
      e.callee = this.normalExpression();
    } catch (i) {
      throw i instanceof T ? (e.callee = i.partialNode, new T(i.token, n(), i.handlerContext)) : i;
    }
    if (this.shouldStopExpression())
      return n();
    let s = e.callee;
    for (; !this.shouldStopExpression(); ) {
      Ze(this.previous()) || this.logError(s, o.MISSING_SPACES, "Expect a following space");
      try {
        s = this.normalExpression(), e.args.push(s);
      } catch (i) {
        throw i instanceof T ? (s = i.partialNode, e.args.push(s), new T(i.token, n(), i.handlerContext)) : i;
      }
    }
    return n();
  }
  shouldStopExpression() {
    if (this.isAtEnd() || St(this.previous()))
      return !0;
    const e = this.peek().kind;
    return e === u.RBRACE || e === u.RBRACKET || e === u.RPAREN || e === u.COMMA || e === u.COLON;
  }
  normalExpression() {
    return this.expression_bp(0);
  }
  // Pratt's parsing algorithm
  expression_bp(e) {
    let n = this.leftExpression_bp();
    for (; !this.isAtEnd(); ) {
      const s = this.peek();
      if (s.kind === u.LPAREN) {
        const { left: i } = bt(s);
        if (i < e || // When '(' is encountered,
        // consider it part of another expression if
        // it's at the start of a new line
        // and we're currently not having unmatched '(' or '['
        Nt(this.previous(), s) && !this.contextStack.isWithinGroupExpressionContext() && !this.contextStack.isWithinListExpressionContext())
          break;
        try {
          n = this.nodeFactory.create(ee, {
            callee: n,
            argumentList: this.tupleExpression()
          });
        } catch (a) {
          throw a instanceof T ? (n = this.nodeFactory.create(ee, {
            callee: n,
            argumentList: a.partialNode
          }), new T(a.token, n, a.handlerContext)) : a;
        }
      } else if (s.kind === u.LBRACKET) {
        if (Ze(this.previous()))
          break;
        try {
          n = this.nodeFactory.create(Ie, {
            expression: n,
            indexer: this.listExpression()
          });
        } catch (i) {
          throw i instanceof T ? (n = this.nodeFactory.create(Ie, {
            expression: n,
            indexer: i.partialNode
          }), new T(i.token, n, i.handlerContext)) : i;
        }
      } else if (Et(s)) {
        const i = s, a = bt(i);
        if (a.left !== null) {
          if (a.left <= e)
            break;
          this.advance(), n = this.nodeFactory.create(qe, {
            expression: n,
            op: i
          });
        } else {
          const r = Bn(i);
          if (r.left === null || r.left <= e)
            break;
          this.advance();
          try {
            n = this.nodeFactory.create(le, {
              leftExpression: n,
              op: i,
              rightExpression: i.value === "." ? this.extractOperand() : this.expression_bp(r.right)
            });
          } catch (c) {
            throw c instanceof T ? (n = this.nodeFactory.create(le, {
              leftExpression: n,
              op: i,
              rightExpression: c.partialNode
            }), new T(c.token, n, c.handlerContext)) : c;
          }
        }
      } else
        break;
    }
    return n;
  }
  leftExpression_bp() {
    let e;
    if (Et(this.peek())) {
      const n = {};
      n.op = this.peek();
      const s = Gn(n.op);
      if (s.right === null)
        throw this.logError(
          n.op,
          o.UNKNOWN_PREFIX_OP,
          `Unexpected '${n.op.value}' in an expression`
        ), new T(
          n.op,
          this.nodeFactory.create(Me, { pre: n.op }),
          this.contextStack.findHandlerContext(this.tokens, this.current)
        );
      this.advance();
      try {
        n.expression = this.expression_bp(s.right);
      } catch (i) {
        throw i instanceof T ? (n.expression = i.partialNode, new T(
          i.token,
          this.nodeFactory.create(Z, n),
          i.handlerContext
        )) : i;
      }
      e = this.nodeFactory.create(Z, n);
    } else if (e = this.extractOperand(), e instanceof Me)
      throw new T(
        this.peek(),
        this.nodeFactory.create(Me, { pre: this.peek() }),
        this.contextStack.findHandlerContext(this.tokens, this.current)
      );
    return e;
  }
  // Extract an operand to be used in a normal form expression
  // e.g (1 + 2) in (1 + 2) * 3
  // e.g [1, 2, 3, 4]
  // e.g { ... }
  extractOperand() {
    return this.check(
      u.NUMERIC_LITERAL,
      u.STRING_LITERAL,
      u.COLOR_LITERAL,
      u.QUOTED_STRING,
      u.IDENTIFIER
    ) ? this.primaryExpression() : this.check(u.FUNCTION_EXPRESSION) ? this.functionExpression() : this.check(u.LBRACKET) ? this.listExpression() : this.check(u.LBRACE) ? this.blockExpression() : this.check(u.LPAREN) ? this.tupleExpression() : (this.peek().kind === u.EOF ? this.logError(
      this.peek(),
      o.UNEXPECTED_EOF,
      "Unexpected EOF"
    ) : this.logError(
      this.peek(),
      o.INVALID_OPERAND,
      `Invalid start of operand "${this.peek().value}"`
    ), this.nodeFactory.create(Me, { pre: this.previous() }));
  }
  /* Parsing FunctionExpression */
  functionExpression() {
    const e = {};
    try {
      this.consume("Expect a function expression", u.FUNCTION_EXPRESSION), e.value = this.previous();
    } catch (n) {
      throw n instanceof T ? (e.value = n.partialNode, new T(
        n.token,
        this.nodeFactory.create(ue, e),
        n.handlerContext
      )) : n;
    }
    return this.nodeFactory.create(ue, e);
  }
  variable() {
    this.consume("Expect a variable", u.IDENTIFIER);
    const e = this.previous();
    return this.nodeFactory.create(re, { variable: e });
  }
  canBeField() {
    return this.peek().kind === u.IDENTIFIER && this.peek(1).kind === u.COLON;
  }
  /* Parsing PrimaryExpression */
  primaryExpression() {
    if (this.match(
      u.COLOR_LITERAL,
      u.STRING_LITERAL,
      u.NUMERIC_LITERAL
    ))
      return this.nodeFactory.create(j, {
        expression: this.nodeFactory.create(ye, { literal: this.previous() })
      });
    if (this.match(u.QUOTED_STRING, u.IDENTIFIER))
      return this.nodeFactory.create(j, {
        expression: this.nodeFactory.create(re, { variable: this.previous() })
      });
    throw this.logError(this.peek(), o.UNEXPECTED_TOKEN, "Expect a variable or literal"), new T(
      this.peek(),
      void 0,
      this.contextStack.findHandlerContext(this.tokens, this.current)
    );
  }
  attribute() {
    const e = {};
    if (this.check(u.COLON, u.RBRACKET, u.COMMA)) {
      const n = this.peek();
      this.logError(
        n,
        o.EMPTY_ATTRIBUTE_NAME,
        "Expect a non-empty attribute name"
      ), e.name = this.nodeFactory.create(ne, { identifiers: [] });
    } else
      try {
        e.name = this.attributeName();
      } catch (n) {
        if (!(n instanceof T))
          throw n;
        if (e.name = n.partialNode, !this.canHandle(n))
          throw new T(
            n.token,
            this.nodeFactory.create(se, e),
            n.handlerContext
          );
        this.synchronizeAttributeName();
      }
    return this.match(u.COLON) && (e.colon = this.previous(), e.value = this.attributeValue()), this.nodeFactory.create(se, e);
  }
  attributeValue() {
    let e;
    try {
      e = this.peek().kind === u.IDENTIFIER && this.peek(1).kind === u.IDENTIFIER ? this.attributeName() : this.normalExpression();
    } catch (n) {
      if (!(n instanceof T) || !this.canHandle(n))
        throw n;
      e = n.partialNode, this.synchronizeAttributeValue();
    }
    return e;
  }
  attributeName() {
    const e = [];
    if (this.peek().kind !== u.IDENTIFIER)
      return this.primaryExpression();
    for (; !this.isAtEnd() && !this.check(u.COLON, u.COMMA, u.RBRACKET); )
      try {
        this.consume("Expect an identifier", u.IDENTIFIER), e.push(this.previous());
      } catch (n) {
        throw n instanceof T ? new T(
          n.token,
          this.nodeFactory.create(ne, { identifiers: e }),
          n.handlerContext
        ) : n;
      }
    return this.nodeFactory.create(ne, { identifiers: e });
  }
  logError(e, n, s) {
    this.errors.push(new l(n, s, e));
  }
}
const Fn = {
  "+": { left: 9, right: 10 },
  "*": { left: 11, right: 12 },
  "-": { left: 9, right: 10 },
  "/": { left: 11, right: 12 },
  "%": { left: 11, right: 12 },
  "<": { left: 7, right: 8 },
  "<=": { left: 7, right: 8 },
  ">": { left: 7, right: 8 },
  ">=": { left: 7, right: 8 },
  "<>": { left: 7, right: 8 },
  "=": { left: 2, right: 3 },
  "==": { left: 4, right: 5 },
  "!=": { left: 4, right: 5 },
  ".": { left: 16, right: 17 }
};
function Bn(t) {
  return Fn[t.value] || { left: null, right: null };
}
const Vn = {
  "+": { left: null, right: 15 },
  "-": { left: null, right: 15 },
  "<": { left: null, right: 15 },
  ">": { left: null, right: 15 },
  "<>": { left: null, right: 15 },
  "!": { left: null, right: 15 }
};
function Gn(t) {
  return Vn[t.value] || { left: null, right: null };
}
const Cn = {
  "(": { left: 14, right: null }
};
function bt(t) {
  return Cn[t.value] || { left: null, right: null };
}
var I = /* @__PURE__ */ ((t) => (t.Table = "table", t.Enum = "enum", t.Ref = "ref", t.Note = "note", t.Project = "project", t.Indexes = "indexes", t.TableGroup = "tablegroup", t.TablePartial = "tablepartial", t))(I || {}), E = /* @__PURE__ */ ((t) => (t.Color = "color", t.HeaderColor = "headercolor", t.Note = "note", t.PK = "pk", t.PKey = "primary key", t.Unique = "unique", t.Ref = "ref", t.NotNull = "not null", t.Null = "null", t.Increment = "increment", t.Default = "default", t.Name = "name", t.Type = "type", t.Update = "update", t.Delete = "delete", t))(E || {});
function Le(t) {
  var n;
  const e = (n = t == null ? void 0 : t.type) == null ? void 0 : n.value.toLowerCase();
  switch (e) {
    case I.Enum:
    case I.Table:
    case I.Indexes:
    case I.Note:
    case I.Project:
    case I.Ref:
    case I.TableGroup:
    case I.TablePartial:
      return new U(e);
    default:
      return new P();
  }
}
function _e(t) {
  if (!ut(t))
    return new U([t]);
  const e = _e(t.leftExpression).unwrap_or(void 0);
  return e ? (e.push(t.rightExpression), new U(e)) : new P();
}
function q(t) {
  if (t === void 0)
    return new P();
  const e = _e(t).unwrap_or(void 0);
  if (!e)
    return new P();
  const n = [];
  for (const s of e) {
    const i = W(s).unwrap_or(void 0);
    if (!i)
      return new P();
    n.push(i);
  }
  return new U(n);
}
function De(t) {
  if (t === void 0)
    return new P();
  const e = _e(t).unwrap_or(void 0);
  if (!e || e.length === 0)
    return new P();
  const n = [];
  let s;
  if (!$(g.last(e))) {
    const i = e.pop();
    if ($t(i))
      s = i.elementList.map(
        (a) => X(a).unwrap()
      );
    else
      return new P();
  }
  for (const i of e) {
    const a = W(i).unwrap_or(void 0);
    if (!a)
      return new P();
    n.push(a);
  }
  return new U({
    variables: n,
    tupleElements: s
  });
}
function W(t) {
  return $(t) ? new U(t.expression.variable.value) : new P();
}
function $e(t) {
  if (It(t))
    return t instanceof ue ? new U({ functional: [t], nonFunctional: [] }) : new U({ functional: [], nonFunctional: [t] });
  if (t instanceof ce && t.elementList.every(It)) {
    const e = t.elementList.filter(
      (s) => s instanceof ue
    ), n = t.elementList.filter($);
    return new U({ functional: e, nonFunctional: n });
  }
  return new P();
}
function X(t) {
  var n;
  const e = (n = t == null ? void 0 : t.expression.variable) == null ? void 0 : n.value;
  return e === void 0 ? new P() : new U(e);
}
function Xn(t) {
  var n, s;
  const e = (s = (n = t == null ? void 0 : t.partial) == null ? void 0 : n.variable) == null ? void 0 : s.value;
  return e === void 0 ? new P() : new U(e);
}
function V(t) {
  return Y(t) ? t.expression instanceof re ? new U(t.expression.variable.value) : new U(t.expression.literal.value) : new P();
}
function $n(t) {
  var e;
  return !(t instanceof le) || !Gt((e = t.op) == null ? void 0 : e.value) ? !1 : De(t.leftExpression).and_then(() => De(t.rightExpression)).unwrap_or(void 0) !== void 0;
}
function jn(t) {
  const e = De(t.leftExpression), n = De(t.rightExpression);
  if (!e.isOk() || !n.isOk())
    return !1;
  const { tupleElements: s } = e.unwrap(), { tupleElements: i } = n.unwrap();
  return (s == null ? void 0 : s.length) === (i == null ? void 0 : i.length);
}
function It(t) {
  return t instanceof j && t.expression instanceof re || t instanceof ue;
}
function Lt(t, e) {
  var i, a, r, c;
  let n = e;
  const s = En(t);
  for (; n; ) {
    if ((a = (i = n.symbol) == null ? void 0 : i.symbolTable) != null && a.has(t))
      return (r = n.symbol.symbolTable) == null ? void 0 : r.get(t);
    if (((c = n.symbol) == null ? void 0 : c.declaration) instanceof K && s)
      return n.symbol;
    if (n instanceof K)
      return;
    n = n.parent;
  }
}
class Wn {
  constructor(e, n, s) {
    this.declarationNode = e, this.publicSymbolTable = n, this.symbolFactory = s;
  }
  validate() {
    return [...this.validateContext(), ...this.validateName(this.declarationNode.name), ...this.validateAlias(this.declarationNode.alias), ...this.validateSettingList(this.declarationNode.attributeList), ...this.validateBody(this.declarationNode.body)];
  }
  validateContext() {
    return this.declarationNode.parent instanceof K || Le(this.declarationNode.parent).unwrap_or(void 0) !== I.Project ? [new l(o.INVALID_CUSTOM_CONTEXT, "A custom element can only appear in a Project", this.declarationNode)] : [];
  }
  validateName(e) {
    return e ? [new l(o.UNEXPECTED_NAME, "A Custom element shouldn't have a name", e)] : [];
  }
  validateAlias(e) {
    return e ? [new l(o.UNEXPECTED_NAME, "A Custom element shouldn't have an alias", e)] : [];
  }
  validateSettingList(e) {
    return e ? [new l(o.UNEXPECTED_SETTINGS, "A Custom element shouldn't have a setting list", e)] : [];
  }
  validateBody(e) {
    if (!e)
      return [];
    if (e instanceof oe)
      return [new l(o.UNEXPECTED_COMPLEX_BODY, "A Custom element can only have an inline field", e)];
    const n = [];
    return Y(e.callee) || n.push(new l(o.INVALID_CUSTOM_ELEMENT_VALUE, "A Custom element value can only be a string", e)), e.args.length > 0 && n.push(...e.args.map((s) => new l(o.INVALID_CUSTOM_ELEMENT_VALUE, "A Custom element value can only be a string", s))), n;
  }
}
class ke {
  constructor() {
    this.table = /* @__PURE__ */ new Map();
  }
  has(e) {
    return this.table.has(e);
  }
  set(e, n) {
    this.table.set(e, n);
  }
  get(e, n) {
    return this.table.get(e) || n !== void 0 && this.set(e, n) || n;
  }
  entries() {
    return this.table.entries();
  }
  forEach(e) {
    return this.table.forEach(e);
  }
}
class Yn {
  constructor(e, n, s) {
    this.declarationNode = e, this.publicSymbolTable = n, this.symbolFactory = s;
  }
  validate() {
    return [...this.validateContext(), ...this.validateName(this.declarationNode.name), ...this.validateAlias(this.declarationNode.alias), ...this.validateSettingList(this.declarationNode.attributeList), ...this.registerElement(), ...this.validateBody(this.declarationNode.body)];
  }
  validateContext() {
    return this.declarationNode.parent instanceof y ? [new l(o.INVALID_PROJECT_CONTEXT, "An Enum can only appear top-level", this.declarationNode)] : [];
  }
  validateName(e) {
    return e ? Vt(e) ? [] : [new l(o.INVALID_NAME, "An Enum name must be of the form <enum> or <schema>.<enum>", e)] : [new l(o.NAME_NOT_FOUND, "An Enum must have a name", this.declarationNode)];
  }
  validateAlias(e) {
    return e ? [new l(o.UNEXPECTED_ALIAS, "A Ref shouldn't have an alias", e)] : [];
  }
  registerElement() {
    const e = [];
    this.declarationNode.symbol = this.symbolFactory.create(bn, { declaration: this.declarationNode, symbolTable: new ke() });
    const { name: n } = this.declarationNode, s = q(n);
    if (s.isOk()) {
      const i = s.unwrap(), a = i.pop(), r = Qe(i, this.publicSymbolTable, this.symbolFactory), c = it(a);
      r.has(c) && e.push(new l(o.DUPLICATE_NAME, `Enum name ${a} already exists in schema '${i.join(".") || "public"}'`, n)), r.set(c, this.declarationNode.symbol);
    }
    return e;
  }
  validateSettingList(e) {
    return e ? [new l(o.UNEXPECTED_SETTINGS, "An Enum shouldn't have a setting list", e)] : [];
  }
  validateBody(e) {
    if (!e)
      return [];
    if (e instanceof w)
      return this.validateFields([e]);
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return [...this.validateFields(n), ...this.validateSubElements(s)];
  }
  validateFields(e) {
    return e.length === 0 ? [new l(o.EMPTY_ENUM, "An Enum must have at least one element", this.declarationNode)] : e.flatMap((n) => {
      const s = [];
      n.callee && !$(n.callee) && s.push(new l(o.INVALID_ENUM_ELEMENT_NAME, "An enum field must be an identifier or a quoted identifier", n.callee));
      const i = [...n.args];
      return g.last(i) instanceof M ? (s.push(...this.validateFieldSettings(g.last(i))), i.pop()) : i[0] instanceof M && (s.push(...this.validateFieldSettings(i[0])), i.shift()), i.length > 0 && s.push(...i.map((a) => new l(o.INVALID_ENUM_ELEMENT, "An Enum must have only a field and optionally a setting list", a))), s.push(...this.registerField(n)), s;
    });
  }
  validateFieldSettings(e) {
    const n = F(e), s = n.getErrors(), i = n.getValue();
    for (const a in i) {
      const r = i[a];
      switch (a) {
        case "note":
          r.length > 1 && r.forEach((c) => s.push(new l(o.DUPLICATE_ENUM_ELEMENT_SETTING, "'note' can only appear once", c))), r.forEach((c) => {
            Y(c.value) || s.push(new l(o.INVALID_ENUM_ELEMENT_SETTING, "'note' must be a string", c));
          });
          break;
        default:
          r.forEach((c) => s.push(new l(o.UNKNOWN_ENUM_ELEMENT_SETTING, `Unknown enum field setting '${a}'`, c)));
      }
    }
    return s;
  }
  validateSubElements(e) {
    return e.flatMap((n) => {
      if (n.parent = this.declarationNode, !n.type)
        return [];
      const s = he(n);
      return new s(n, this.publicSymbolTable, this.symbolFactory).validate();
    });
  }
  registerField(e) {
    if (e.callee && $(e.callee)) {
      const n = X(e.callee).unwrap(), s = at(n), i = this.symbolFactory.create(In, { declaration: e });
      e.symbol = i;
      const a = this.declarationNode.symbol.symbolTable;
      if (a.has(s)) {
        const r = a.get(s);
        return [
          new l(o.DUPLICATE_COLUMN_NAME, `Duplicate enum field ${n}`, e),
          new l(o.DUPLICATE_COLUMN_NAME, `Duplicate enum field ${n}`, r.declaration)
        ];
      }
      a.set(s, i);
    }
    return [];
  }
}
class qn {
  constructor(e, n, s) {
    this.declarationNode = e, this.publicSymbolTable = n, this.symbolFactory = s;
  }
  validate() {
    return [
      ...this.validateContext(),
      ...this.validateName(this.declarationNode.name),
      ...this.validateAlias(this.declarationNode.alias),
      ...this.validateSettingList(this.declarationNode.attributeList),
      ...this.validateBody(this.declarationNode.body)
    ];
  }
  validateContext() {
    const e = new l(
      o.INVALID_INDEXES_CONTEXT,
      "An Indexes can only appear inside a Table or a TablePartial",
      this.declarationNode
    );
    if (this.declarationNode.parent instanceof K) return [e];
    const n = Le(this.declarationNode.parent).unwrap_or(void 0);
    return n && [I.Table, I.TablePartial].includes(n) ? [] : [e];
  }
  validateName(e) {
    return e ? [new l(o.UNEXPECTED_NAME, "An Indexes shouldn't have a name", e)] : [];
  }
  validateAlias(e) {
    return e ? [new l(o.UNEXPECTED_ALIAS, "An Indexes shouldn't have an alias", e)] : [];
  }
  validateSettingList(e) {
    return e ? [new l(o.UNEXPECTED_SETTINGS, "An Indexes shouldn't have a setting list", e)] : [];
  }
  validateBody(e) {
    if (!e)
      return [];
    if (e instanceof w)
      return [new l(o.UNEXPECTED_SIMPLE_BODY, "An Indexes must have a complex body", e)];
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return [...this.validateFields(n), ...this.validateSubElements(s)];
  }
  validateFields(e) {
    return e.flatMap((n) => {
      if (!n.callee)
        return [];
      const s = [], i = [n.callee, ...n.args];
      return g.last(i) instanceof M && s.push(...this.validateFieldSetting(i.pop())), i.forEach((a) => {
        for (; a instanceof ee; )
          a.argumentList && !$e(a.argumentList).isOk() && s.push(new l(o.INVALID_INDEXES_FIELD, "An index field must be an identifier, a quoted identifier, a functional expression or a tuple of such", a.argumentList)), a = a.callee;
        $e(a).isOk() || s.push(new l(o.INVALID_INDEXES_FIELD, "An index field must be an identifier, a quoted identifier, a functional expression or a tuple of such", a));
      }), s;
    });
  }
  validateFieldSetting(e) {
    const n = F(e), s = n.getErrors(), i = n.getValue();
    for (const a in i) {
      const r = i[a];
      switch (a) {
        case "note":
        case "name":
          r.length > 1 && r.forEach((c) => s.push(new l(o.DUPLICATE_INDEX_SETTING, `'${a}' can only appear once`, c))), r.forEach((c) => {
            Y(c.value) || s.push(new l(o.INVALID_INDEX_SETTING_VALUE, `'${a}' must be a string`, c));
          });
          break;
        case "unique":
        case "pk":
          r.length > 1 && r.forEach((c) => s.push(new l(o.DUPLICATE_INDEX_SETTING, `'${a}' can only appear once`, c))), r.forEach((c) => {
            z(c.value) || s.push(new l(o.INVALID_INDEX_SETTING_VALUE, `'${a}' must not have a value`, c));
          });
          break;
        case "type":
          r.length > 1 && r.forEach((c) => s.push(new l(o.DUPLICATE_INDEX_SETTING, "'type' can only appear once", c))), r.forEach((c) => {
            $(c.value) || s.push(new l(o.INVALID_INDEX_SETTING_VALUE, `'type' must be "btree" or "hash"`, c));
          });
          break;
        default:
          r.forEach((c) => s.push(new l(o.UNKNOWN_INDEX_SETTING, `Unknown index setting '${a}'`, c)));
      }
    }
    return s;
  }
  validateSubElements(e) {
    return e.flatMap((n) => {
      if (n.parent = this.declarationNode, !n.type)
        return [];
      const s = he(n);
      return new s(n, this.publicSymbolTable, this.symbolFactory).validate();
    });
  }
}
class Hn {
  constructor(e, n, s) {
    this.declarationNode = e, this.publicSymbolTable = n, this.symbolFactory = s;
  }
  validate() {
    return [
      ...this.validateContext(),
      ...this.validateName(this.declarationNode.name),
      ...this.validateAlias(this.declarationNode.alias),
      ...this.validateSettingList(this.declarationNode.attributeList),
      ...this.validateBody(this.declarationNode.body)
    ];
  }
  validateContext() {
    return !(this.declarationNode.parent instanceof K) && ![
      I.Table,
      I.TableGroup,
      I.TablePartial,
      I.Project
    ].includes(Le(this.declarationNode.parent).unwrap_or(void 0)) ? [new l(
      o.INVALID_NOTE_CONTEXT,
      "A Note can only appear inside a Table, a TableGroup, a TablePartial or a Project. Sticky note can only appear at the global scope.",
      this.declarationNode
    )] : [];
  }
  validateName(e) {
    if (!(this.declarationNode.parent instanceof K))
      return e ? [new l(o.UNEXPECTED_NAME, "A Note shouldn't have a name", e)] : [];
    if (!e)
      return [new l(o.INVALID_NAME, "Sticky note must have a name", this.declarationNode)];
    const n = q(e);
    if (!n.isOk()) return [new l(o.INVALID_NAME, "Invalid name for sticky note ", this.declarationNode)];
    const i = n.unwrap().join("."), a = dn(i);
    return this.publicSymbolTable.has(a) ? [new l(o.DUPLICATE_NAME, `Sticky note "${i}" has already been defined`, e)] : (this.publicSymbolTable.set(a, this.declarationNode.symbol), []);
  }
  validateAlias(e) {
    return e ? [new l(o.UNEXPECTED_ALIAS, "A Ref shouldn't have an alias", e)] : [];
  }
  validateSettingList(e) {
    return e ? [new l(o.UNEXPECTED_SETTINGS, "A Note shouldn't have a setting list", e)] : [];
  }
  validateBody(e) {
    if (!e)
      return [];
    if (e instanceof w)
      return this.validateFields([e]);
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return [...this.validateFields(n), ...this.validateSubElements(s)];
  }
  validateFields(e) {
    const n = [];
    return e.length === 0 ? [new l(o.EMPTY_NOTE, "A Note must have a content", this.declarationNode)] : (e.length > 1 && e.slice(1).forEach((s) => n.push(new l(o.NOTE_CONTENT_REDEFINED, "A Note can only contain one string", s))), Y(e[0].callee) || n.push(new l(o.INVALID_NOTE, "A Note content must be a quoted string", e[0])), e[0].args.length > 0 && n.push(...e[0].args.map((s) => new l(o.INVALID_NOTE, "A Note can only contain one quoted string", s))), n);
  }
  validateSubElements(e) {
    return e.flatMap((n) => {
      if (n.parent = this.declarationNode, !n.type)
        return [];
      const s = he(n);
      return new s(n, this.publicSymbolTable, this.symbolFactory).validate();
    });
  }
}
class zn {
  constructor(e, n, s) {
    this.declarationNode = e, this.publicSymbolTable = n, this.symbolFactory = s;
  }
  validate() {
    return [...this.validateContext(), ...this.validateName(this.declarationNode.name), ...this.validateAlias(this.declarationNode.alias), ...this.validateSettingList(this.declarationNode.attributeList), ...this.validateBody(this.declarationNode.body)];
  }
  validateContext() {
    return this.declarationNode.parent instanceof y ? [new l(o.INVALID_PROJECT_CONTEXT, "A Project can only appear top-level", this.declarationNode)] : [];
  }
  validateName(e) {
    return e ? Pe(e) ? [] : [new l(o.INVALID_NAME, "A Project's name is optional or must be an identifier or a quoted identifer", e)] : [];
  }
  validateAlias(e) {
    return e ? [new l(o.UNEXPECTED_ALIAS, "A Project shouldn't have an alias", e)] : [];
  }
  validateSettingList(e) {
    return e ? [new l(o.UNEXPECTED_SETTINGS, "A Project shouldn't have a setting list", e)] : [];
  }
  validateBody(e) {
    if (!e)
      return [];
    if (e instanceof w)
      return [new l(o.UNEXPECTED_SIMPLE_BODY, "A Project's body must be a block", e)];
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return [
      ...n.map((i) => new l(o.INVALID_PROJECT_FIELD, "A Project can not have inline fields", i)),
      ...this.validateSubElements(s)
    ];
  }
  validateSubElements(e) {
    return e.flatMap((n) => {
      if (n.parent = this.declarationNode, !n.type)
        return [];
      const s = he(n);
      return new s(n, this.publicSymbolTable, this.symbolFactory).validate();
    });
  }
}
class Qn {
  constructor(e, n, s) {
    this.declarationNode = e, this.publicSymbolTable = n, this.symbolFactory = s;
  }
  validate() {
    return [...this.validateContext(), ...this.validateName(this.declarationNode.name), ...this.validateAlias(this.declarationNode.alias), ...this.validateSettingList(this.declarationNode.attributeList), ...this.validateBody(this.declarationNode.body)];
  }
  validateContext() {
    return this.declarationNode.parent instanceof K ? [] : [new l(o.INVALID_REF_CONTEXT, "A Ref must appear top-level", this.declarationNode)];
  }
  validateName(e) {
    return e ? Pe(e) ? [] : [new l(o.INVALID_NAME, "A Ref's name is optional or must be an identifier or a quoted identifer", e)] : [];
  }
  validateAlias(e) {
    return e ? [new l(o.UNEXPECTED_ALIAS, "A Ref shouldn't have an alias", e)] : [];
  }
  validateSettingList(e) {
    return e ? [new l(o.UNEXPECTED_SETTINGS, "A Ref shouldn't have a setting list", e)] : [];
  }
  validateBody(e) {
    if (!e)
      return [];
    if (e instanceof w)
      return this.validateFields([e]);
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return [...this.validateFields(n), ...this.validateSubElements(s)];
  }
  validateFields(e) {
    if (e.length === 0)
      return [new l(o.EMPTY_REF, "A Ref must have at least one field", this.declarationNode)];
    const n = [];
    return e.length > 1 && n.push(...e.slice(1).map((s) => new l(o.REF_REDEFINED, "A Ref can only contain one binary relationship", s))), e.forEach((s) => {
      s.callee && !$n(s.callee) && n.push(new l(o.INVALID_REF_FIELD, "A Ref field must be a binary relationship", s.callee)), s.callee && !jn(s.callee) && n.push(new l(o.UNEQUAL_FIELDS_BINARY_REF, "Unequal fields in ref endpoints", s.callee));
      const i = [...s.args];
      if (g.last(i) instanceof M) {
        const a = this.validateFieldSettings(g.last(i));
        n.push(...a), i.pop();
      } else i[0] instanceof M && (n.push(...this.validateFieldSettings(i[0])), i.shift());
      i.length > 0 && n.push(...i.map((a) => new l(o.INVALID_REF_FIELD, "A Ref field should only have a single binary relationship", a)));
    }), n;
  }
  validateFieldSettings(e) {
    const n = F(e), s = n.getErrors(), i = n.getValue();
    for (const a in i) {
      const r = i[a];
      switch (a) {
        case "delete":
        case "update":
          r.length > 1 && r.forEach((c) => s.push(new l(o.DUPLICATE_REF_SETTING, `'${a}' can only appear once`, c))), r.forEach((c) => {
            Jn(c.value) || s.push(new l(o.INVALID_REF_SETTING_VALUE, `'${a}' can only have values "cascade", "no action", "set null", "set default" or "restrict"`, c));
          });
          break;
        case "color":
          r.length > 1 && s.push(...r.map((c) => new l(o.DUPLICATE_REF_SETTING, "'color' can only appear once", c))), r.forEach((c) => {
            Je(c.value) || s.push(new l(o.INVALID_REF_SETTING_VALUE, "'color' must be a color literal", c));
          });
          break;
        default:
          r.forEach((c) => s.push(new l(o.UNKNOWN_REF_SETTING, `Unknown ref setting '${a}'`, c)));
      }
    }
    return s;
  }
  validateSubElements(e) {
    return e.flatMap((n) => {
      if (n.parent = this.declarationNode, !n.type)
        return [];
      const s = he(n);
      return new s(n, this.publicSymbolTable, this.symbolFactory).validate();
    });
  }
}
function Jn(t) {
  if (!($(t) && t.expression.variable.kind !== u.QUOTED_STRING) && !(t instanceof ne))
    return !1;
  let e;
  if (t instanceof ne ? e = we(t).unwrap_or("") : e = t.expression.variable.value, e)
    switch (e.toLowerCase()) {
      case "cascade":
      case "no action":
      case "set null":
      case "set default":
      case "restrict":
        return !0;
      default:
        return !1;
    }
  return !1;
}
class Kn {
  constructor(e, n, s) {
    this.declarationNode = e, this.symbolFactory = s, this.publicSymbolTable = n;
  }
  validate() {
    return [
      ...this.validateContext(),
      ...this.validateName(this.declarationNode.name),
      ...this.validateAlias(this.declarationNode.alias),
      ...this.validateSettingList(this.declarationNode.attributeList),
      ...this.registerElement(),
      ...this.validateBody(this.declarationNode.body)
    ];
  }
  validateContext() {
    return this.declarationNode.parent instanceof y ? [new l(o.INVALID_TABLE_CONTEXT, "Table must appear top-level", this.declarationNode)] : [];
  }
  validateName(e) {
    return e ? e instanceof Ie ? [new l(o.INVALID_NAME, "Invalid array as Table name, maybe you forget to add a space between the name and the setting list?", e)] : Vt(e) ? [] : [new l(o.INVALID_NAME, "A Table name must be of the form <table> or <schema>.<table>", e)] : [new l(o.NAME_NOT_FOUND, "A Table must have a name", this.declarationNode)];
  }
  validateAlias(e) {
    return e ? ss(e) ? [] : [new l(o.INVALID_ALIAS, "Table aliases can only contains alphanumeric and underscore unless surrounded by double quotes", e)] : [];
  }
  validateSettingList(e) {
    const n = F(e), s = n.getErrors(), i = n.getValue();
    return Ge(i, (a, r) => {
      switch (r) {
        case E.HeaderColor:
          a.length > 1 && s.push(...a.map((c) => new l(o.DUPLICATE_TABLE_SETTING, "'headercolor' can only appear once", c))), a.forEach((c) => {
            Je(c.value) || s.push(new l(o.INVALID_TABLE_SETTING, "'headercolor' must be a color literal", c.value || c.name));
          });
          break;
        case E.Note:
          a.length > 1 && s.push(...a.map((c) => new l(o.DUPLICATE_TABLE_SETTING, "'note' can only appear once", c))), a.forEach((c) => {
            Y(c.value) || s.push(new l(o.INVALID_TABLE_SETTING, "'note' must be a string literal", c.value || c.name));
          });
          break;
        default:
          s.push(...a.map((c) => new l(o.INVALID_TABLE_SETTING, `Unknown '${r}' setting`, c)));
      }
    }), s;
  }
  registerElement() {
    const e = [];
    this.declarationNode.symbol = this.symbolFactory.create(Mt, { declaration: this.declarationNode, symbolTable: new ke() });
    const { name: n, alias: s } = this.declarationNode, i = q(n);
    if (i.isOk()) {
      const a = [...i.unwrap()], r = a.pop(), c = Qe(a, this.publicSymbolTable, this.symbolFactory), f = Ce(r);
      c.has(f) && e.push(new l(o.DUPLICATE_NAME, `Table name '${r}' already exists in schema '${a.join(".") || "public"}'`, n)), c.set(f, this.declarationNode.symbol);
    }
    if (s && Pe(s) && !Zn(s.expression.variable.value, i.unwrap_or([]))) {
      const a = X(s).unwrap(), r = Ce(a);
      this.publicSymbolTable.has(r) && e.push(new l(o.DUPLICATE_NAME, `Table name '${a}' already exists`, n)), this.publicSymbolTable.set(r, this.declarationNode.symbol);
    }
    return e;
  }
  validateBody(e) {
    if (!e)
      return [];
    if (e instanceof w)
      return [new l(o.UNEXPECTED_SIMPLE_BODY, "A Table's body must be a block", e)];
    const [n, s, i] = e.body.reduce((a, r) => (r instanceof w ? a[0].push(r) : r instanceof be ? a[1].push(r) : r instanceof y && a[2].push(r), a), [[], [], []]);
    return [
      ...this.validateFields(n),
      ...this.validateInjections(s),
      ...this.validateSubElements(i)
    ];
  }
  validateInjections(e) {
    return e.flatMap((n) => this.registerInjection(n));
  }
  registerInjection(e) {
    var c, f, p;
    if (!((f = (c = e.partial) == null ? void 0 : c.variable) != null && f.value)) return [];
    const n = (p = e.partial.variable) == null ? void 0 : p.value, s = Rt(n), i = this.symbolFactory.create(gn, { declaration: e });
    e.symbol = i;
    const a = this.declarationNode.symbol.symbolTable, r = a.get(s);
    return r ? [
      new l(o.DUPLICATE_TABLE_PARTIAL_INJECTION_NAME, `Duplicate injection ${n}`, e),
      new l(o.DUPLICATE_TABLE_PARTIAL_INJECTION_NAME, `Duplicate injection ${n}`, r.declaration)
    ] : (a.set(s, i), []);
  }
  validateFields(e) {
    return e.flatMap((n) => {
      if (!n.callee)
        return [];
      const s = [];
      n.args.length === 0 && s.push(new l(o.INVALID_COLUMN, "A column must have a type", n.callee)), $(n.callee) || s.push(new l(o.INVALID_COLUMN_NAME, "A column name must be an identifier or a quoted identifier", n.callee)), n.args[0] && !jt(n.args[0]) && s.push(new l(o.INVALID_COLUMN_TYPE, "Invalid column type", n.args[0]));
      const i = n.args.slice(1);
      return s.push(...this.validateFieldSetting(i)), s.push(...this.registerField(n)), s;
    });
  }
  registerField(e) {
    if (e.callee && $(e.callee)) {
      const n = X(e.callee).unwrap(), s = He(n), i = this.symbolFactory.create(ct, { declaration: e });
      e.symbol = i;
      const a = this.declarationNode.symbol.symbolTable;
      if (a.has(s)) {
        const r = a.get(s);
        return [
          new l(o.DUPLICATE_COLUMN_NAME, `Duplicate column ${n}`, e),
          new l(o.DUPLICATE_COLUMN_NAME, `Duplicate column ${n}`, r.declaration)
        ];
      }
      a.set(s, i);
    }
    return [];
  }
  // This is needed to support legacy inline settings
  validateFieldSetting(e) {
    if (!e.slice(0, -1).every(Ne) || !e.slice(-1).every((f) => Ne(f) || f instanceof M))
      return [...e.map((f) => new l(o.INVALID_COLUMN, "These fields must be some inline settings optionally ended with a setting list", f))];
    if (e.length === 0)
      return [];
    let n;
    g.last(e) instanceof M && (n = e.pop());
    const s = F(n), i = s.getErrors(), a = s.getValue();
    e.forEach((f) => {
      const p = X(f).unwrap_or("").toLowerCase();
      if (p !== "pk" && p !== "unique") {
        i.push(new l(o.INVALID_SETTINGS, "Inline column settings can only be `pk` or `unique`", f));
        return;
      }
      a[p] === void 0 ? a[p] = [f] : a[p].push(f);
    });
    const r = a[E.PK] || [], c = a[E.PKey] || [];
    return r.length >= 1 && c.length >= 1 && i.push(
      ...[...r, ...c].map((f) => new l(o.DUPLICATE_COLUMN_SETTING, "Either one of 'primary key' and 'pk' can appear", f))
    ), Ge(a, (f, p) => {
      switch (p) {
        case E.Note:
          f.length > 1 && i.push(...f.map((h) => new l(o.DUPLICATE_COLUMN_SETTING, "note can only appear once", h))), f.forEach((h) => {
            Y(h.value) || i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'note' must be a quoted string", h.value || h.name));
          });
          break;
        case E.Ref:
          f.forEach((h) => {
            Xt(h.value) || i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'ref' must be a valid unary relationship", h.value || h.name));
          });
          break;
        case E.PKey:
          f.length > 1 && i.push(...f.map((h) => new l(o.DUPLICATE_COLUMN_SETTING, "primary key can only appear once", h))), f.forEach((h) => {
            z(h.value) || i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'primary key' must not have a value", h.value || h.name));
          });
          break;
        case E.PK:
          f.length > 1 && i.push(...f.map((h) => new l(o.DUPLICATE_COLUMN_SETTING, "'pk' can only appear once", h))), f.forEach((h) => {
            h instanceof se && !z(h.value) && i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'pk' must not have a value", h.value || h.name));
          });
          break;
        case E.NotNull: {
          f.length > 1 && i.push(...f.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, "'not null' can only appear once", d)));
          const h = a[E.Null] || [];
          f.length >= 1 && h.length >= 1 && i.push(
            ...[...f, ...h].map((d) => new l(o.CONFLICTING_SETTING, "'not null' and 'null' can not be set at the same time", d))
          ), f.forEach((d) => {
            z(d.value) || i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'not null' must not have a value", d.value || d.name));
          });
          break;
        }
        case E.Null:
          f.length > 1 && i.push(...f.map((h) => new l(o.DUPLICATE_COLUMN_SETTING, "'null' can only appear once", h))), f.forEach((h) => {
            z(h.value) || i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'null' must not have a value", h.value || h.name));
          });
          break;
        case E.Unique:
          f.length > 1 && i.push(...f.map((h) => new l(o.DUPLICATE_COLUMN_SETTING, "'unique' can only appear once", h))), f.forEach((h) => {
            h instanceof se && !z(h.value) && i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'unique' must not have a value", h.value || h.name));
          });
          break;
        case E.Increment:
          f.length > 1 && i.push(...f.map((h) => new l(o.DUPLICATE_COLUMN_SETTING, "'increment' can only appear once", h))), f.forEach((h) => {
            h instanceof se && !z(h.value) && i.push(new l(o.INVALID_COLUMN_SETTING_VALUE, "'increment' must not have a value", h.value || h.name));
          });
          break;
        case E.Default:
          f.length > 1 && i.push(...f.map((h) => new l(o.DUPLICATE_TABLE_SETTING, "'default' can only appear once", h))), f.forEach((h) => {
            Ct(h.value) || i.push(new l(
              o.INVALID_TABLE_SETTING,
              "'default' must be a string literal, number literal, function expression, true, false or null",
              h.value || h.name
            ));
          });
          break;
        default:
          f.forEach((h) => i.push(new l(o.UNKNOWN_COLUMN_SETTING, `Unknown column setting '${p}'`, h)));
      }
    }), i;
  }
  validateSubElements(e) {
    const n = e.flatMap((i) => {
      if (i.parent = this.declarationNode, !i.type)
        return [];
      const a = he(i);
      return new a(i, this.publicSymbolTable, this.symbolFactory).validate();
    }), s = e.filter((i) => {
      var a;
      return ((a = i.type) == null ? void 0 : a.value.toLowerCase()) === "note";
    });
    return s.length > 1 && n.push(...s.map((i) => new l(o.NOTE_REDEFINED, "Duplicate notes are defined", i))), n;
  }
}
function Zn(t, e) {
  return e.length === 1 && t === e[0];
}
class es {
  constructor(e, n, s) {
    this.declarationNode = e, this.publicSymbolTable = n, this.symbolFactory = s;
  }
  validate() {
    return [
      ...this.validateContext(),
      ...this.validateName(this.declarationNode.name),
      ...this.validateAlias(this.declarationNode.alias),
      ...this.validateSettingList(this.declarationNode.attributeList),
      ...this.registerElement(),
      ...this.validateBody(this.declarationNode.body)
    ];
  }
  validateContext() {
    return this.declarationNode.parent instanceof y ? [new l(
      o.INVALID_TABLEGROUP_CONTEXT,
      "TableGroup must appear top-level",
      this.declarationNode
    )] : [];
  }
  validateName(e) {
    return e ? Pe(e) ? [] : [new l(
      o.INVALID_NAME,
      "A TableGroup name must be a single identifier",
      e
    )] : [new l(
      o.NAME_NOT_FOUND,
      "A TableGroup must have a name",
      this.declarationNode
    )];
  }
  validateAlias(e) {
    return e ? [new l(
      o.UNEXPECTED_ALIAS,
      "A TableGroup shouldn't have an alias",
      e
    )] : [];
  }
  registerElement() {
    const { name: e } = this.declarationNode;
    this.declarationNode.symbol = this.symbolFactory.create(Ln, { declaration: this.declarationNode, symbolTable: new ke() });
    const n = q(e);
    if (n.isOk()) {
      const s = n.unwrap(), i = s.pop(), a = Qe(s, this.publicSymbolTable, this.symbolFactory), r = rt(i);
      if (a.has(r))
        return [new l(o.DUPLICATE_NAME, `TableGroup name '${i}' already exists`, e)];
      a.set(r, this.declarationNode.symbol);
    }
    return [];
  }
  validateSettingList(e) {
    const n = F(e), s = n.getErrors(), i = n.getValue();
    return g.forIn(i, (a, r) => {
      switch (r) {
        case "color":
          a.length > 1 && s.push(...a.map((c) => new l(
            o.DUPLICATE_TABLE_SETTING,
            "'color' can only appear once",
            c
          ))), a.forEach((c) => {
            Je(c.value) || s.push(new l(
              o.INVALID_TABLE_SETTING,
              "'color' must be a color literal",
              c.value || c.name
            ));
          });
          break;
        case "note":
          a.length > 1 && s.push(...a.map((c) => new l(
            o.DUPLICATE_TABLE_SETTING,
            "'note' can only appear once",
            c
          ))), a.filter((c) => !Y(c.value)).forEach((c) => {
            s.push(new l(
              o.INVALID_TABLE_SETTING,
              "'note' must be a string literal",
              c.value || c.name
            ));
          });
          break;
        default:
          s.push(...a.map((c) => new l(
            o.INVALID_TABLE_SETTING,
            `Unknown '${r}' setting`,
            c
          )));
          break;
      }
    }), s;
  }
  validateBody(e) {
    if (!e) return [];
    if (e instanceof w)
      return [new l(
        o.UNEXPECTED_SIMPLE_BODY,
        "A TableGroup's body must be a block",
        e
      )];
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return [
      ...this.validateFields(n),
      ...this.validateSubElements(s)
    ];
  }
  validateFields(e) {
    return e.flatMap((n) => {
      const s = [];
      return n.callee && !q(n.callee).isOk() && s.push(new l(o.INVALID_TABLEGROUP_FIELD, "A TableGroup field must be of the form <table> or <schema>.<table>", n.callee)), this.registerField(n), n.args.length > 0 && s.push(...n.args.map((i) => new l(o.INVALID_TABLEGROUP_FIELD, "A TableGroup field should only have a single Table name", i))), s;
    });
  }
  validateSubElements(e) {
    const n = e.flatMap((i) => {
      if (i.parent = this.declarationNode, !i.type)
        return [];
      const a = he(i);
      return new a(i, this.publicSymbolTable, this.symbolFactory).validate();
    }), s = e.filter((i) => {
      var a;
      return ((a = i.type) == null ? void 0 : a.value.toLowerCase()) === "note";
    });
    return s.length > 1 && n.push(...s.map((i) => new l(o.NOTE_REDEFINED, "Duplicate notes are defined", i))), n;
  }
  registerField(e) {
    if (e.callee && $(e.callee)) {
      const n = X(e.callee).unwrap(), s = ot(n), i = this.symbolFactory.create(An, { declaration: e });
      e.symbol = i;
      const a = this.declarationNode.symbol.symbolTable;
      if (a.has(s)) {
        const r = a.get(s);
        return [
          new l(o.DUPLICATE_TABLEGROUP_FIELD_NAME, `${n} already exists in the group`, e),
          new l(o.DUPLICATE_TABLEGROUP_FIELD_NAME, `${n} already exists in the group`, r.declaration)
        ];
      }
      a.set(s, i);
    }
    return [];
  }
}
const ts = ["-", "+"];
class ns {
  constructor(e, n, s) {
    this.declarationNode = e, this.symbolFactory = s, this.publicSymbolTable = n;
  }
  validate() {
    return [
      ...this.validateContext(),
      ...this.validateName(this.declarationNode.name),
      ...this.validateAlias(this.declarationNode.alias),
      ...this.validateSettingList(this.declarationNode.attributeList),
      ...this.registerElement(),
      ...this.validateBody(this.declarationNode.body)
    ];
  }
  validateContext() {
    return this.declarationNode.parent instanceof y ? [new l(
      o.INVALID_TABLE_PARTIAL_CONTEXT,
      "TablePartial must appear top-level",
      this.declarationNode
    )] : [];
  }
  validateName(e) {
    return e ? Pe(e) ? [] : [new l(
      o.INVALID_NAME,
      "A TablePartial name must be an identifier or a quoted identifer",
      e
    )] : [new l(
      o.NAME_NOT_FOUND,
      "A TablePartial must have a name",
      this.declarationNode
    )];
  }
  validateAlias(e) {
    return e ? [new l(
      o.UNEXPECTED_ALIAS,
      "A TablePartial shouldn't have an alias",
      e
    )] : [];
  }
  validateSettingList(e) {
    const n = F(e), s = n.getErrors(), i = n.getValue();
    return Ge(i, (a, r) => {
      switch (r) {
        case E.HeaderColor:
          a.length > 1 && s.push(...a.map((c) => new l(o.DUPLICATE_TABLE_PARTIAL_SETTING, `'${r}' can only appear once`, c))), a.forEach((c) => {
            Je(c.value) || s.push(new l(o.INVALID_TABLE_PARTIAL_SETTING, `'${r}' must be a color literal`, c.value || c.name));
          });
          break;
        case E.Note:
          a.length > 1 && s.push(...a.map((c) => new l(o.DUPLICATE_TABLE_PARTIAL_SETTING, `'${r}' can only appear once`, c))), a.forEach((c) => {
            Y(c.value) || s.push(new l(o.INVALID_TABLE_PARTIAL_SETTING, `'${r}' must be a string literal`, c.value || c.name));
          });
          break;
        default:
          s.push(...a.map((c) => new l(o.INVALID_TABLE_SETTING, `Unknown '${r}' setting`, c)));
      }
    }), s;
  }
  registerElement() {
    const { name: e } = this.declarationNode;
    this.declarationNode.symbol = this.symbolFactory.create(_n, { declaration: this.declarationNode, symbolTable: new ke() });
    const n = q(e);
    if (!n.isOk()) return [];
    const s = n.unwrap(), i = s.pop(), a = Qe(s, this.publicSymbolTable, this.symbolFactory), r = lt(i);
    return a.has(r) ? [new l(o.DUPLICATE_NAME, `TablePartial name '${i}' already exists`, e)] : (a.set(r, this.declarationNode.symbol), []);
  }
  validateBody(e) {
    if (!e) return [];
    if (e instanceof w)
      return [new l(o.UNEXPECTED_SIMPLE_BODY, "A TablePartial's body must be a block", e)];
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return [
      ...this.validateFields(n),
      ...this.validateSubElements(s)
    ];
  }
  validateFields(e) {
    return e.flatMap((n) => {
      if (!n.callee) return [];
      const s = [];
      n.args.length === 0 && s.push(new l(o.INVALID_COLUMN, "A column must have a type", n.callee)), $(n.callee) || s.push(new l(o.INVALID_COLUMN_NAME, "A column name must be an identifier or a quoted identifier", n.callee)), n.args[0] && !jt(n.args[0]) && s.push(new l(o.INVALID_COLUMN_TYPE, "Invalid column type", n.args[0]));
      const i = n.args.slice(1);
      return s.push(
        ...this.validateFieldSetting(i),
        ...this.registerField(n)
      ), s;
    });
  }
  registerField(e) {
    if (!e.callee || !$(e.callee)) return [];
    const n = X(e.callee).unwrap(), s = He(n), i = this.symbolFactory.create(ct, { declaration: e });
    e.symbol = i;
    const a = this.declarationNode.symbol.symbolTable;
    if (a.has(s)) {
      const r = a.get(s);
      return [
        new l(o.DUPLICATE_COLUMN_NAME, `Duplicate column ${n}`, e),
        new l(o.DUPLICATE_COLUMN_NAME, `Duplicate column ${n}`, r.declaration)
      ];
    }
    return a.set(s, i), [];
  }
  // This is needed to support legacy inline settings
  validateFieldSetting(e) {
    const n = Ve(e);
    if (!e.slice(0, -1).every(Ne) || !(Ne(n) || n instanceof M))
      return [...e.map((p) => new l(o.INVALID_COLUMN, "These fields must be some inline settings optionally ended with a setting list", p))];
    if (e.length === 0) return [];
    let s;
    g.last(e) instanceof M && (s = e.pop());
    const i = F(s), a = i.getErrors(), r = i.getValue();
    e.forEach((p) => {
      const h = X(p).unwrap_or("").toLowerCase();
      if (h !== E.PK && h !== E.Unique) {
        a.push(new l(o.INVALID_SETTINGS, "Inline column settings can only be `pk` or `unique`", p));
        return;
      }
      r[h] === void 0 ? r[h] = [p] : r[h].push(p);
    });
    const c = r[E.PK] || [], f = r[E.PKey] || [];
    return c.length >= 1 && f.length >= 1 && a.push(...[...c, ...f].map((p) => new l(
      o.DUPLICATE_COLUMN_SETTING,
      "Either one of 'primary key' and 'pk' can appear",
      p
    ))), Ge(r, (p, h) => {
      switch (h) {
        case E.Note:
          p.length > 1 && a.push(...p.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, d))), p.forEach((d) => {
            Y(d.value) || a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must be a quoted string`, d.value || d.name));
          });
          break;
        case E.Ref:
          p.forEach((d) => {
            Xt(d.value) || a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must be a valid unary relationship`, d.value || d.name));
          });
          break;
        case E.PKey:
          p.length > 1 && a.push(...p.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, d))), p.forEach((d) => {
            z(d.value) || a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must not have a value`, d.value || d.name));
          });
          break;
        case E.PK:
          p.length > 1 && a.push(...p.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, d))), p.forEach((d) => {
            d instanceof se && !z(d.value) && a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must not have a value`, d.value || d.name));
          });
          break;
        case E.NotNull: {
          p.length > 1 && a.push(...p.map((N) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, N)));
          const d = r[E.Null] || [];
          p.length >= 1 && d.length >= 1 && a.push(...[...p, ...d].map((N) => new l(
            o.CONFLICTING_SETTING,
            "'not null' and 'null' can not be set at the same time",
            N
          ))), p.forEach((N) => {
            z(N.value) || a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must not have a value`, N.value || N.name));
          });
          break;
        }
        case E.Null:
          p.length > 1 && a.push(...p.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, d))), p.forEach((d) => {
            z(d.value) || a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must not have a value`, d.value || d.name));
          });
          break;
        case E.Unique:
          p.length > 1 && a.push(...p.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, d))), p.forEach((d) => {
            d instanceof se && !z(d.value) && a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must not have a value`, d.value || d.name));
          });
          break;
        case E.Increment:
          p.length > 1 && a.push(...p.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, d))), p.forEach((d) => {
            d instanceof se && !z(d.value) && a.push(new l(o.INVALID_COLUMN_SETTING_VALUE, `'${h}' must not have a value`, d.value || d.name));
          });
          break;
        case E.Default:
          p.length > 1 && a.push(...p.map((d) => new l(o.DUPLICATE_COLUMN_SETTING, `'${h}' can only appear once`, d))), p.forEach((d) => {
            Ct(d.value) || a.push(new l(
              o.INVALID_COLUMN_SETTING_VALUE,
              `'${h}' must be a string literal, number literal, function expression, true, false or null`,
              d.value || d.name
            ));
          });
          break;
        default:
          p.forEach((d) => a.push(new l(o.UNKNOWN_COLUMN_SETTING, `Unknown column setting '${h}'`, d)));
      }
    }), a;
  }
  validateSubElements(e) {
    const n = e.flatMap((i) => {
      if (i.parent = this.declarationNode, !i.type)
        return [];
      const a = he(i);
      return new a(i, this.publicSymbolTable, this.symbolFactory).validate();
    }), s = e.filter((i) => {
      var a;
      return ((a = i.type) == null ? void 0 : a.value.toLowerCase()) === I.Note;
    });
    return s.length > 1 && n.push(...s.map((i) => new l(o.NOTE_REDEFINED, "Duplicate notes are defined", i))), n;
  }
}
function he(t) {
  switch (t.type.value.toLowerCase()) {
    case I.Enum:
      return Yn;
    case I.Table:
      return Kn;
    case I.TableGroup:
      return es;
    case I.Project:
      return zn;
    case I.Ref:
      return Qn;
    case I.Note:
      return Hn;
    case I.Indexes:
      return qn;
    case I.TablePartial:
      return ns;
    default:
      return Wn;
  }
}
function Vt(t) {
  return !!q(t).unwrap_or(!1);
}
function ss(t) {
  return Pe(t);
}
function Pe(t) {
  return t instanceof j && t.expression instanceof re;
}
function Qe(t, e, n) {
  var i;
  t[0] === "public" && (t = t.slice(1));
  let s = e;
  for (const a of t) {
    let r;
    const c = st(a);
    if (s.has(c)) {
      if (r = (i = s.get(c)) == null ? void 0 : i.symbolTable, !r)
        throw new Error("Expect a symbol table in a schema symbol");
    } else {
      r = new ke();
      const f = n.create(Ut, { symbolTable: r });
      s.set(c, f);
    }
    s = r;
  }
  return s;
}
function Gt(t) {
  return t === "-" || t === "<>" || t === ">" || t === "<";
}
function Je(t) {
  var n;
  if (!(t instanceof j) || !(t.expression instanceof ye) || ((n = t.expression.literal) == null ? void 0 : n.kind) !== u.COLOR_LITERAL)
    return !1;
  const e = t.expression.literal.value;
  if (e.length !== 4 && e.length !== 7 || e[0] !== "#")
    return !1;
  for (let s = 1; s < e.length; s += 1)
    if (!kn(e[s]))
      return !1;
  return !0;
}
function z(t) {
  return t === void 0;
}
function Ct(t) {
  var e;
  return !!(Y(t) || Ae(t) || Ne(t) && ["true", "false", "null"].includes(t.expression.variable.value.toLowerCase()) || t instanceof Z && ts.includes((e = t.op) == null ? void 0 : e.value) && Ae(t.expression) || t instanceof ue);
}
function Ae(t) {
  var e, n, s;
  return t instanceof Z ? ((e = t.op) == null ? void 0 : e.value) !== "-" && ((n = t.op) == null ? void 0 : n.value) !== "+" ? !1 : Ae(t.expression) : t instanceof j && t.expression instanceof ye && ((s = t.expression.literal) == null ? void 0 : s.kind) === u.NUMERIC_LITERAL;
}
function Xt(t) {
  var n;
  if (!(t instanceof Z) || !Gt((n = t.op) == null ? void 0 : n.value))
    return !1;
  const e = q(t.expression).unwrap_or(void 0);
  return e !== void 0 && e.length > 0;
}
function $t(t) {
  return t instanceof ce && t.elementList.every($);
}
function jt(t) {
  if (!(t instanceof ee || ut(t) || t instanceof j || t instanceof Ie))
    return !1;
  if (t instanceof ee) {
    if (t.callee === void 0 || t.argumentList === void 0 || !t.argumentList.elementList.every((n) => Ae(n) || Y(n) || Ne(n)))
      return !1;
    t = t.callee;
  }
  for (; t instanceof Ie; ) {
    if (t.array === void 0 || t.indexer === void 0 || !t.indexer.elementList.every((n) => !n.colon && !n.value && Ae(n.name)))
      return !1;
    t = t.array;
  }
  const e = q(t).unwrap_or(void 0);
  return e !== void 0 && e.length > 0;
}
function F(t) {
  var s;
  const e = {}, n = [];
  if (!t)
    return new J({});
  for (const i of t.elementList) {
    if (!i.name)
      continue;
    if (i.name instanceof j) {
      n.push(new l(o.INVALID_SETTINGS, "A setting name must be a stream of identifiers", i.name));
      continue;
    }
    const a = (s = we(i.name).unwrap_or(void 0)) == null ? void 0 : s.toLowerCase();
    a && (e[a] === void 0 ? e[a] = [i] : e[a].push(i));
  }
  return new J(e, n);
}
class At {
  constructor(e, n) {
    this.ast = e, this.symbolFactory = n, this.publicSchemaSymbol = this.symbolFactory.create(Ut, {
      symbolTable: new ke()
    }), this.ast.symbol = this.publicSchemaSymbol, this.ast.symbol.declaration = this.ast;
  }
  validate() {
    const e = [];
    this.ast.body.forEach((s) => {
      if (s.parent = this.ast, s.type === void 0)
        return;
      const i = he(s), a = new i(
        s,
        this.publicSchemaSymbol.symbolTable,
        this.symbolFactory
      );
      e.push(...a.validate());
    });
    const n = this.ast.body.filter((s) => Le(s).unwrap_or(void 0) === I.Project);
    return n.length > 1 && n.forEach((s) => e.push(new l(o.PROJECT_REDEFINED, "Only one project can exist", s))), new J(this.ast, e);
  }
}
class fe {
  constructor(e, n) {
    this.declarationNode = e, this.errors = n;
  }
  bind() {
    this.bindSettingList(this.declarationNode.attributeList, this.settingList), this.bindBody();
  }
  bindSettingList(e, n) {
    e && e.elementList.forEach((s) => {
      if (s.name instanceof j) return;
      const i = we(s.name).unwrap_or(void 0);
      if (!i) return;
      const a = n[i.toLowerCase()];
      a != null && a.shouldBind && this.scanAndBind(s.value, a);
    });
  }
  bindBody() {
    const e = this.declarationNode;
    if (!e.body) return;
    const { body: n } = e;
    n instanceof oe ? n.body.forEach((s) => {
      if (s instanceof y) {
        if (!s.type || Le(this.declarationNode).unwrap_or(null) === I.TablePartial && Le(s).unwrap_or(null) === I.Indexes) return;
        const i = Wt(s);
        new i(s, this.errors).bind();
      } else s instanceof w ? this.bindSubfield(s) : this.bindPartialInjection(s);
    }) : this.bindSubfield(n);
  }
  bindSubfield(e) {
    const n = [e.callee, ...e.args], s = g.last(n);
    s instanceof M && (n.pop(), this.bindSettingList(s, this.subfield.settingList));
    const { argBinderRules: i } = this.subfield.arg;
    for (let a = 0; a < Math.min(n.length, i.length); a += 1)
      i[a].shouldBind && this.scanAndBind(n[a], i[a]);
  }
  bindPartialInjection(e) {
    var n;
    (n = this.injectionBinderRule) != null && n.shouldBind && this.scanAndBind(e, this.injectionBinderRule);
  }
  // Scan for variable node and member access expression in the node to bind
  scanAndBind(e, n) {
    var s, i;
    if (e)
      if (e instanceof j) {
        if (e.expression instanceof re && ((i = n.keywords) != null && i.includes((s = e.expression.variable) == null ? void 0 : s.value.toLowerCase())))
          return;
        this.bindFragments([e], n);
      } else e instanceof le ? ut(e) ? this.bindFragments(_e(e).unwrap_or([]), n) : (this.scanAndBind(e.leftExpression, n), this.scanAndBind(e.rightExpression, n)) : e instanceof Z ? this.scanAndBind(e.expression, n) : e instanceof qe ? this.scanAndBind(e.expression, n) : e instanceof ce ? e.elementList.forEach((a) => this.scanAndBind(a, n)) : e instanceof be && this.bindFragments([e], n);
  }
  // Bind the fragments of a member access expression
  // which can be a simple expression like v1.User,
  // or a complex tuple like v1.User.(id, name)
  bindFragments(e, n) {
    if (e.length === 0) return;
    const s = e.length === 1 && e[0] instanceof be, i = [...n.topSubnamesSymbolKind], { remainingSubnamesSymbolKind: a } = n, r = s ? -1 : e.findIndex((N) => !$(N)), f = r !== -1 && $t(e[r]) ? e[r] : void 0, p = r >= 0 ? i.pop() : void 0, h = e.slice(
      0,
      r === -1 ? void 0 : r
    );
    if (h.length === 0) return;
    const d = [];
    for (; i.length && h.length; ) {
      const N = i.pop(), L = h.pop(), v = X(L).unwrap();
      d.unshift({
        index: Fe(v, N),
        referrer: L
      });
    }
    for (; h.length; ) {
      const N = h.pop(), L = s ? Xn(N).unwrap() : X(N).unwrap();
      d.unshift({
        index: Fe(L, a),
        referrer: N
      });
    }
    return f ? f.elementList.forEach((N) => this.resolveIndexStack(
      [
        ...d,
        {
          index: Fe(
            X(N).unwrap(),
            p
          ),
          referrer: N
        }
      ],
      n.ignoreNameNotFound
    )) : this.resolveIndexStack(d, n.ignoreNameNotFound);
  }
  // Looking up the indexes in the subname stack from the current declaration node
  // Each time the index resolves to a symbol, the referrer's symbol is bound to it
  resolveIndexStack(e, n) {
    if (e.length === 0)
      throw new Error("Unreachable - An unresolved name must have at least one name component");
    const [s, ...i] = e, a = Lt(s.index, this.declarationNode);
    if (a === void 0) {
      const { kind: p, name: h } = ie(s.index).unwrap();
      this.logError(s.referrer, `Can not find ${p} '${h}'`, n);
      return;
    }
    a.references.push(s.referrer), s.referrer.referee = a;
    let r = a.symbolTable, { kind: c, name: f } = ie(s.index).unwrap();
    for (const p of i) {
      const { kind: h, name: d } = ie(p.index).unwrap(), N = r.get(p.index);
      if (!N) {
        this.logError(
          p.referrer,
          `${c} '${f}' does not have ${h} '${d}'`,
          n
        );
        return;
      }
      if (c = h, f = d, p.referrer.referee = N, N.references.push(p.referrer), !N.symbolTable)
        break;
      r = N.symbolTable;
    }
  }
  logError(e, n, s) {
    s || this.errors.push(new l(o.BINDING_ERROR, n, e));
  }
  // Resolve fields from partial injections into current element's symbol table so binder will have fields when binding
  resolveInjections(e) {
    var i;
    const n = (i = this.declarationNode.symbol) == null ? void 0 : i.symbolTable;
    if (!n) return;
    const s = /* @__PURE__ */ new Map();
    n.forEach((a, r) => {
      var p, h;
      if (!Nn(r)) return;
      const c = Lt(Tn(r), this.declarationNode), f = (h = (p = c == null ? void 0 : c.declaration) == null ? void 0 : p.symbol) == null ? void 0 : h.symbolTable;
      f && f.forEach((d, N) => {
        n.has(N) || s.set(N, { injectorFieldSymbol: d, injectorDeclaration: a.declaration });
      });
    }), s.forEach((a, r) => {
      const c = yn(a.injectorFieldSymbol);
      if (!c) return;
      const f = e.create(c, a);
      n.set(r, f);
    });
  }
}
class is extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: []
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class as extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [{ shouldBind: !1 }]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class rs extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Table, m.Column],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !1
          },
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Table, m.Column],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !1
          },
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Table, m.Column],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !1
          },
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Table, m.Column],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !1
          }
        ]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class os extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [{ shouldBind: !1 }]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class ls extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: []
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class cs extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Table, m.Column],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !1
          }
        ]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class us extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          { shouldBind: !1 },
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Enum],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !0
          }
        ]
      },
      settingList: {
        ref: {
          shouldBind: !0,
          topSubnamesSymbolKind: [m.Table, m.Column],
          remainingSubnamesSymbolKind: m.Schema,
          ignoreNameNotFound: !1
        },
        default: {
          shouldBind: !1
        }
      }
    }, this.settingList = {}, this.injectionBinderRule = {
      shouldBind: !0,
      topSubnamesSymbolKind: [],
      remainingSubnamesSymbolKind: m.TablePartial,
      ignoreNameNotFound: !1
    };
  }
}
class hs extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Table],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !1
          }
        ]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class fs extends fe {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          { shouldBind: !1 },
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [m.Enum],
            remainingSubnamesSymbolKind: m.Schema,
            ignoreNameNotFound: !0
          }
        ]
      },
      settingList: {
        ref: {
          shouldBind: !0,
          topSubnamesSymbolKind: [m.Table, m.Column],
          remainingSubnamesSymbolKind: m.Schema,
          ignoreNameNotFound: !1
        },
        default: {
          shouldBind: !1
        }
      }
    }, this.settingList = {};
  }
}
function Wt(t) {
  switch (t.type.value.toLowerCase()) {
    case I.Enum:
      return as;
    case I.Table:
      return us;
    case I.TableGroup:
      return hs;
    case I.Project:
      return ls;
    case I.Ref:
      return cs;
    case I.Note:
      return os;
    case I.Indexes:
      return rs;
    case I.TablePartial:
      return fs;
    default:
      return is;
  }
}
class ps {
  constructor(e) {
    this.ast = e, this.errors = [];
  }
  resolve(e) {
    return this.ast.body.map((n) => {
      if (!n.type) return null;
      const s = Wt(n), i = new s(n, this.errors);
      return i.resolveInjections(e), i;
    }).forEach((n) => n == null ? void 0 : n.bind()), new J(this.ast, this.errors);
  }
}
class ds {
  constructor(e) {
    this.generator = e;
  }
  create(e, n) {
    return new e(n, this.generator.nextId());
  }
}
class Es {
  constructor(e, n) {
    this.ast = e, this.symbolFactory = new ds(n);
  }
  // Analyzing: Invoking both the validator and binder
  analyze() {
    return new At(this.ast, this.symbolFactory).validate().chain((n) => new ps(n).resolve(this.symbolFactory));
  }
  // For invoking the validator only
  validate() {
    return new At(this.ast, this.symbolFactory).validate().chain((n) => new J(n, []));
  }
}
function _t(t, e) {
  const { variables: n, tupleElements: s } = De(t).unwrap();
  return s ? n.length === 0 ? {
    schemaName: e.schemaName,
    tableName: e.name,
    fieldNames: s
  } : {
    tableName: n.pop(),
    schemaName: n.pop() || null,
    fieldNames: s
  } : n.length === 1 ? {
    schemaName: e.schemaName,
    tableName: e.name,
    fieldNames: [n[0]]
  } : {
    fieldNames: [n.pop()],
    tableName: n.pop(),
    schemaName: n.pop() || null
  };
}
function Yt(t) {
  switch (t) {
    case "<":
      return ["1", "*"];
    case "<>":
      return ["*", "*"];
    case ">":
      return ["*", "1"];
    case "-":
      return ["1", "1"];
    default:
      throw new Error("Invalid relation op");
  }
}
function _(t) {
  return {
    start: {
      offset: t.startPos.offset,
      line: t.startPos.line + 1,
      column: t.startPos.column + 1
    },
    end: {
      offset: t.endPos.offset,
      line: t.endPos.line + 1,
      column: t.endPos.column + 1
    }
  };
}
function je(t) {
  var n;
  const e = (n = _e(t).unwrap_or(void 0)) == null ? void 0 : n.pop();
  return e instanceof ce ? e.elementList.map((s) => s.referee) : [e.referee];
}
function ge(t) {
  const e = q(t).unwrap();
  return {
    name: e.pop(),
    schemaName: e
  };
}
function Oe(t) {
  return t.expression.literal.value;
}
function qt(t, e) {
  if (Array.isArray(t)) {
    const i = t.map(({ id: r }) => r).sort().join(","), a = e.map(({ id: r }) => r).sort().join(",");
    return i < a ? `${i}-${a}` : `${a}-${i}`;
  }
  const n = t.id.toString(), s = e.id.toString();
  return n < s ? `${n}-${s}` : `${s}-${n}`;
}
function ht(t, e) {
  if (Array.isArray(t)) {
    const i = t.map(({ id: r }) => r).sort(), a = e.map(({ id: r }) => r).sort();
    return g.zip(i, a).every(([r, c]) => r === c);
  }
  const n = t.id, s = e.id;
  return n === s;
}
function ae(t) {
  const e = t.split(`
`), n = e.slice(e.findIndex((a) => a.trimStart() !== "")), s = n.filter((a) => a.trimStart()), i = Math.min(...s.map((a) => a.length - a.trimStart().length));
  return n.map((a) => a.slice(i)).join(`
`);
}
function Ht(t) {
  if (t) {
    if (Y(t))
      return {
        value: V(t).unwrap(),
        type: "string"
      };
    if (Ae(t))
      return {
        type: "number",
        value: et(t)
      };
    if (Ne(t))
      return {
        value: t.expression.variable.value.toLowerCase(),
        type: "boolean"
      };
    if (t instanceof ue && t.value)
      return {
        value: t.value.value,
        type: "expression"
      };
    throw new Error("Unreachable");
  }
}
function zt(t) {
  let e = null;
  t instanceof ee && (e = t.argumentList.elementList.map((a) => Ae(a) ? Ft(a) : Y(a) ? V(a).unwrap() : W(a).unwrap()).join(","), t = t.callee);
  let n = "";
  for (; t instanceof Ie; )
    n = `[${t.indexer.elementList.map((a) => a.name.expression.literal.value).join(",")}]${n}`, t = t.array;
  const { name: s, schemaName: i } = ge(t);
  return i.length > 1 ? new J(
    {
      schemaName: i.length === 0 ? null : i[0],
      type_name: `${s}${n}${e ? `(${e})` : ""}`,
      args: e
    },
    [new l(o.UNSUPPORTED, "Nested schema is not supported", t)]
  ) : new J({
    schemaName: i.length === 0 ? null : i[0],
    type_name: `${s}${n}${e ? `(${e})` : ""}`,
    args: e
  });
}
class Qt {
  constructor(e, n) {
    this.declarationNode = e, this.env = n, this.table = {
      name: void 0,
      schemaName: void 0,
      alias: null,
      fields: [],
      token: void 0,
      indexes: [],
      partials: []
    }, this.pkColumns = [];
  }
  interpret() {
    this.table.token = _(this.declarationNode), this.env.tables.set(this.declarationNode, this.table);
    const e = [
      ...this.interpretName(this.declarationNode.name),
      ...this.interpretAlias(this.declarationNode.alias),
      ...this.interpretSettingList(this.declarationNode.attributeList),
      ...this.interpretBody(this.declarationNode.body)
    ];
    return this.pkColumns.length >= 2 && (this.table.indexes.push({
      columns: this.pkColumns.map(({ name: n, token: s }) => ({ value: n, type: "column", token: s })),
      token: {
        start: { offset: -1, line: -1, column: -1 },
        // do not make sense to have a meaningful start (?)
        end: { offset: -1, line: -1, column: -1 }
        // do not make sense to have a meaningful end (?)
      },
      pk: !0
    }), this.pkColumns.forEach((n) => {
      n.pk = !1;
    })), e;
  }
  interpretName(e) {
    const { name: n, schemaName: s } = ge(e);
    return s.length > 1 ? (this.table.name = n, this.table.schemaName = s.join("."), [new l(o.UNSUPPORTED, "Nested schema is not supported", e)]) : (this.table.name = n, this.table.schemaName = s.length ? s[0] : null, []);
  }
  interpretAlias(e) {
    if (!e)
      return [];
    const n = X(e).unwrap_or(null);
    return n && (this.env.aliases.push({
      name: n,
      kind: "table",
      value: {
        tableName: this.table.name,
        schemaName: this.table.schemaName
      }
    }), this.table.alias = n), [];
  }
  interpretSettingList(e) {
    var i, a, r;
    const n = F(e).getValue();
    this.table.headerColor = (i = n[E.HeaderColor]) != null && i.length ? Oe((r = (a = n[E.HeaderColor]) == null ? void 0 : a.at(0)) == null ? void 0 : r.value) : void 0;
    const [s] = n[E.Note] || [];
    return this.table.note = s && {
      value: V(s == null ? void 0 : s.value).map(ae).unwrap(),
      token: _(s)
    }, [];
  }
  interpretBody(e) {
    const [n, s] = g.partition(e.body, (i) => i instanceof w || i instanceof be);
    return [
      ...this.interpretFields(n),
      ...this.interpretSubElements(s)
    ];
  }
  interpretSubElements(e) {
    return e.flatMap((n) => {
      var s;
      switch ((s = n.type) == null ? void 0 : s.value.toLowerCase()) {
        case I.Note:
          return this.table.note = {
            value: V(
              n.body instanceof oe ? n.body.body[0].callee : n.body.callee
            ).map(ae).unwrap(),
            token: _(n)
          }, [];
        case I.Indexes:
          return this.interpretIndexes(n);
        default:
          return [];
      }
    });
  }
  interpretInjection(e, n) {
    const s = { order: n, token: _(e) };
    return s.name = e.partial.variable.value, this.table.partials.push(s), [];
  }
  interpretFields(e) {
    var r;
    const i = ((r = this.declarationNode.symbol) != null && r.symbolTable ? [...this.declarationNode.symbol.symbolTable.entries()] : []).filter(([c]) => {
      const f = ie(c).unwrap_or(null);
      return (f == null ? void 0 : f.kind) === m.Column;
    }).length ? [] : [new l(o.EMPTY_TABLE, "A Table must have at least one column", this.declarationNode)], a = e.flatMap((c, f) => c instanceof w ? this.interpretColumn(c) : this.interpretInjection(c, f));
    return [
      ...i,
      ...a
    ];
  }
  interpretColumn(e) {
    var r, c, f, p, h, d, N, L, v;
    const n = [], s = {};
    s.name = X(e.callee).unwrap();
    const i = zt(e.args[0]);
    s.type = i.getValue(), n.push(...i.getErrors()), s.token = _(e), s.inline_refs = [];
    const a = e.args.slice(1);
    if (g.last(a) instanceof M) {
      const A = F(a.pop()).getValue();
      s.pk = !!((r = A[E.PK]) != null && r.length) || !!((c = A[E.PKey]) != null && c.length), s.increment = !!((f = A[E.Increment]) != null && f.length), s.unique = !!((p = A[E.Unique]) != null && p.length), s.not_null = (h = A[E.NotNull]) != null && h.length ? !0 : (d = A[E.Null]) != null && d.length ? !1 : void 0, s.dbdefault = Ht((L = (N = A[E.Default]) == null ? void 0 : N.at(0)) == null ? void 0 : L.value);
      const S = (v = A[E.Note]) == null ? void 0 : v.at(0);
      s.note = S && {
        value: V(S.value).map(ae).unwrap(),
        token: _(S)
      };
      const Te = A[E.Ref] || [];
      s.inline_refs = Te.flatMap((D) => {
        const [Ue] = je(D.value.expression);
        if (ht(Ue, e.symbol))
          return n.push(new l(o.SAME_ENDPOINT, "Two endpoints are the same", D)), [];
        const pe = D.value.op, B = q(D.value.expression).unwrap();
        let te;
        if (B.length === 1) {
          const [H] = B;
          te = {
            schemaName: this.table.schemaName,
            tableName: this.table.name,
            fieldNames: [H],
            relation: pe.value,
            token: _(D)
          };
        } else if (B.length === 2) {
          const [H, Ee] = B;
          te = {
            schemaName: null,
            tableName: H,
            fieldNames: [Ee],
            relation: pe.value,
            token: _(D)
          };
        } else if (B.length === 3) {
          const [H, Ee, dt] = B;
          te = {
            schemaName: H,
            tableName: Ee,
            fieldNames: [dt],
            relation: pe.value,
            token: _(D)
          };
        } else {
          n.push(new l(o.UNSUPPORTED, "Nested schema is not supported", D));
          const H = B.pop(), Ee = B.pop();
          te = {
            schemaName: B.join("."),
            tableName: Ee,
            fieldNames: [H],
            relation: pe.value,
            token: _(D)
          };
        }
        const de = this.registerInlineRefToEnv(e, Ue, te, D);
        return n.push(...de), de.length === 0 ? te : [];
      });
    }
    return s.pk || (s.pk = a.some((A) => W(A).unwrap().toLowerCase() === "pk")), s.unique || (s.unique = a.some((A) => W(A).unwrap().toLowerCase() === "unique")), this.table.fields.push(s), s.pk && this.pkColumns.push(s), n;
  }
  interpretIndexes(e) {
    return this.table.indexes.push(...e.body.body.map((n) => {
      var r, c, f, p, h, d, N;
      const s = { columns: [] }, i = n;
      s.token = _(i);
      const a = [i.callee, ...i.args];
      if (g.last(a) instanceof M) {
        const L = F(a.pop()).getValue();
        s.pk = !!((r = L[E.PK]) != null && r.length), s.unique = !!((c = L[E.Unique]) != null && c.length), s.name = V((p = (f = L[E.Name]) == null ? void 0 : f.at(0)) == null ? void 0 : p.value).unwrap_or(void 0);
        const v = (h = L[E.Note]) == null ? void 0 : h.at(0);
        s.note = v && {
          value: V(v.value).unwrap(),
          token: _(v)
        }, s.type = W((N = (d = L[E.Type]) == null ? void 0 : d.at(0)) == null ? void 0 : N.value).unwrap_or(void 0);
      }
      return a.flatMap((L) => {
        if (!(L instanceof ee))
          return L;
        const v = [];
        for (; L instanceof ee; )
          v.push(L.argumentList), L = L.callee;
        return v.push(L), v;
      }).forEach((L) => {
        const { functional: v, nonFunctional: A } = $e(L).unwrap();
        s.columns.push(
          ...v.map((S) => ({
            value: S.value.value,
            type: "expression",
            token: _(S)
          })),
          ...A.map((S) => ({
            value: X(S).unwrap(),
            type: "column",
            token: _(S)
          }))
        );
      }), s;
    })), [];
  }
  registerInlineRefToEnv(e, n, s, i) {
    const a = qt(e.symbol, n);
    if (this.env.refIds[a])
      return [
        new l(o.CIRCULAR_REF, "References with same endpoints exist", i),
        new l(o.CIRCULAR_REF, "References with same endpoints exist", this.env.refIds[a])
      ];
    const r = Yt(s.relation);
    return this.env.refIds[a] = i, this.env.ref.set(i, {
      name: null,
      schemaName: null,
      token: s.token,
      endpoints: [
        {
          ...s,
          relation: r[1]
        },
        {
          schemaName: this.table.schemaName,
          tableName: this.table.name,
          fieldNames: [W(e.callee).unwrap()],
          token: _(e),
          relation: r[0]
        }
      ]
    }), [];
  }
}
class Ns {
  constructor(e, n) {
    this.declarationNode = e, this.env = n, this.note = { name: void 0, content: void 0, token: void 0 };
  }
  interpret() {
    return this.note.token = _(this.declarationNode), this.env.notes.set(this.declarationNode, this.note), [
      ...this.interpretName(this.declarationNode.name),
      ...this.interpretSettingList(this.declarationNode.attributeList),
      ...this.interpretBody(this.declarationNode.body)
    ];
  }
  interpretName(e) {
    const { name: n } = ge(e);
    return this.note.name = n, [];
  }
  interpretSettingList(e) {
    var s, i, a;
    const n = F(e).getValue();
    return this.note.headerColor = (s = n.headercolor) != null && s.length ? Oe((a = (i = n.headercolor) == null ? void 0 : i.at(0)) == null ? void 0 : a.value) : void 0, [];
  }
  interpretBody(e) {
    const [n, s] = g.partition(e.body, (i) => i instanceof w);
    return n.length !== 1 || s.length > 0 ? [
      new l(o.INVALID_NOTE, "Invalid note syntax", e)
    ] : [...this.interpretNote(n[0])];
  }
  interpretNote(e) {
    const n = g.get(e, "callee.expression.literal.value", "");
    return this.note.content = ae(n), [];
  }
}
class Jt {
  constructor(e, n) {
    this.declarationNode = e, this.env = n, this.container = this.declarationNode.parent instanceof y ? this.env.tables.get(this.declarationNode.parent) : void 0, this.ref = {};
  }
  interpret() {
    return this.ref.token = _(this.declarationNode), this.env.ref.set(this.declarationNode, this.ref), [
      ...this.interpretName(this.declarationNode.name),
      ...this.interpretBody(this.declarationNode.body)
    ];
  }
  interpretName(e) {
    const n = [], s = q(this.declarationNode.name).unwrap_or([]);
    return this.ref.name = s.pop() || null, s.length > 1 && n.push(new l(o.UNSUPPORTED, "Nested schema is not supported", this.declarationNode.name)), this.ref.schemaName = s.join(".") || null, n;
  }
  interpretBody(e) {
    return e instanceof w ? this.interpretField(e) : this.interpretField(e.body[0]);
  }
  interpretField(e) {
    var p, h, d, N, L, v, A;
    const n = e.callee.op.value, { leftExpression: s, rightExpression: i } = e.callee, a = je(s), r = je(i);
    if (ht(a, r))
      return [new l(o.SAME_ENDPOINT, "Two endpoints are the same", e)];
    const c = qt(a, r);
    if (this.env.refIds[c])
      return [
        new l(o.CIRCULAR_REF, "References with same endpoints exist", this.declarationNode),
        new l(o.CIRCULAR_REF, "References with same endpoints exist", this.env.refIds[c])
      ];
    if (e.args[0]) {
      const S = F(e.args[0]).getValue(), Te = (h = (p = S.delete) == null ? void 0 : p.at(0)) == null ? void 0 : h.value;
      this.ref.onDelete = Te instanceof ne ? we(Te).unwrap_or(void 0) : W(Te).unwrap_or(void 0);
      const D = (N = (d = S.update) == null ? void 0 : d.at(0)) == null ? void 0 : N.value;
      this.ref.onUpdate = D instanceof ne ? we(D).unwrap_or(void 0) : W(D).unwrap_or(void 0), this.ref.color = (L = S.color) != null && L.length ? Oe((A = (v = S.color) == null ? void 0 : v.at(0)) == null ? void 0 : A.value) : void 0;
    }
    const f = Yt(n);
    return this.ref.endpoints = [
      {
        ..._t(s, this.container),
        relation: f[0],
        token: _(s)
      },
      {
        ..._t(i, this.container),
        relation: f[1],
        token: _(i)
      }
    ], this.env.refIds[c] = this.declarationNode, [];
  }
}
class Kt {
  constructor(e, n) {
    this.declarationNode = e, this.env = n, this.tableGroup = { tables: [] };
  }
  interpret() {
    const e = [];
    return this.tableGroup.token = _(this.declarationNode), this.env.tableGroups.set(this.declarationNode, this.tableGroup), e.push(
      ...this.interpretName(this.declarationNode.name),
      ...this.interpretSettingList(this.declarationNode.attributeList),
      ...this.interpretBody(this.declarationNode.body)
    ), e;
  }
  interpretName(e) {
    const n = [], { name: s, schemaName: i } = ge(e);
    return i.length >= 2 && (this.tableGroup.name = s, this.tableGroup.schemaName = i.join("."), n.push(new l(o.UNSUPPORTED, "Nested schema is not supported", this.declarationNode.name))), this.tableGroup.name = s, this.tableGroup.schemaName = i[0] || null, n;
  }
  interpretBody(e) {
    const [n, s] = Pt(e.body, (i) => i instanceof w);
    return [
      ...this.interpretFields(n),
      ...this.interpretSubElements(s)
    ];
  }
  interpretSubElements(e) {
    return e.flatMap((n) => {
      var s;
      switch ((s = n.type) == null ? void 0 : s.value.toLowerCase()) {
        case "note":
          this.tableGroup.note = {
            value: V(
              n.body instanceof oe ? n.body.body[0].callee : n.body.callee
            ).map(ae).unwrap(),
            token: _(n)
          };
          break;
      }
      return [];
    });
  }
  interpretFields(e) {
    const n = [];
    return this.tableGroup.tables = e.map((s) => {
      const i = q(s.callee).unwrap();
      i.length > 2 && n.push(new l(o.UNSUPPORTED, "Nested schema is not supported", s));
      const a = _e(s.callee).unwrap().pop().referee.id;
      if (this.env.groupOfTable[a]) {
        const r = this.env.groupOfTable[a], { schemaName: c, name: f } = this.env.tableGroups.get(r), p = c ? `${c}.${f}` : f;
        n.push(new l(o.TABLE_REAPPEAR_IN_TABLEGROUP, `Table "${i.join(".")}" already appears in group "${p}"`, s));
      } else
        this.env.groupOfTable[a] = this.declarationNode;
      return {
        name: i.pop(),
        schemaName: i.join(".")
      };
    }), n;
  }
  interpretSettingList(e) {
    var i, a, r;
    const n = F(e).getValue();
    this.tableGroup.color = (i = n.color) != null && i.length ? Oe((r = (a = n.color) == null ? void 0 : a.at(0)) == null ? void 0 : r.value) : void 0;
    const [s] = n.note || [];
    return this.tableGroup.note = s && {
      value: V(s == null ? void 0 : s.value).map(ae).unwrap(),
      token: _(s)
    }, [];
  }
}
class Zt {
  constructor(e, n) {
    this.declarationNode = e, this.env = n, this.enum = { values: [] };
  }
  interpret() {
    return this.enum.token = _(this.declarationNode), this.env.enums.set(this.declarationNode, this.enum), [...this.interpretName(this.declarationNode.name), ...this.interpretBody(this.declarationNode.body)];
  }
  interpretName(e) {
    const { name: n, schemaName: s } = ge(e);
    return s.length > 1 ? (this.enum.name = n, this.enum.schemaName = s.join("."), [new l(o.UNSUPPORTED, "Nested schema is not supported", e)]) : (this.enum.name = n, this.enum.schemaName = s.length ? s[0] : null, []);
  }
  interpretBody(e) {
    return e.body.flatMap((n) => {
      var c;
      const s = n, i = {};
      i.token = _(s), i.name = W(s.callee).unwrap();
      const r = (c = F(s.args[0]).getValue().note) == null ? void 0 : c.at(0);
      return i.note = r && {
        value: V(r.value).map(ae).unwrap(),
        token: _(r)
      }, this.enum.values.push(i), [];
    });
  }
}
class en {
  constructor(e, n) {
    this.declarationNode = e, this.env = n, this.tablePartial = {
      name: void 0,
      fields: [],
      token: void 0,
      indexes: []
    }, this.pkColumns = [];
  }
  interpret() {
    this.tablePartial.token = _(this.declarationNode), this.env.tablePartials.set(this.declarationNode, this.tablePartial);
    const e = [
      ...this.interpretName(this.declarationNode.name),
      ...this.interpretSettingList(this.declarationNode.attributeList),
      ...this.interpretBody(this.declarationNode.body)
    ];
    return this.pkColumns.length >= 2 && (this.tablePartial.indexes.push({
      columns: this.pkColumns.map(({ name: n, token: s }) => ({ value: n, type: "column", token: s })),
      token: {
        start: { offset: -1, line: -1, column: -1 },
        // do not make sense to have a meaningful start (?)
        end: { offset: -1, line: -1, column: -1 }
        // do not make sense to have a meaningful end (?)
      },
      pk: !0
    }), this.pkColumns.forEach((n) => {
      n.pk = !1;
    })), e;
  }
  interpretName(e) {
    const { name: n } = ge(e);
    return this.tablePartial.name = n, [];
  }
  interpretSettingList(e) {
    const n = F(e).getValue(), s = ln(n[E.HeaderColor]);
    this.tablePartial.headerColor = s ? Oe(s.value) : void 0;
    const [i] = n[E.Note] || [];
    return this.tablePartial.note = i && {
      value: V(i == null ? void 0 : i.value).map(ae).unwrap(),
      token: _(i)
    }, [];
  }
  interpretBody(e) {
    const [n, s] = Pt(e.body, (i) => i instanceof w);
    return [
      ...this.interpretFields(n),
      ...this.interpretSubElements(s)
    ];
  }
  interpretSubElements(e) {
    return e.flatMap((n) => {
      var s;
      switch ((s = n.type) == null ? void 0 : s.value.toLowerCase()) {
        case I.Note:
          return this.tablePartial.note = {
            value: V(
              n.body instanceof oe ? n.body.body[0].callee : n.body.callee
            ).map(ae).unwrap(),
            token: _(n)
          }, [];
        case I.Indexes:
          return this.interpretIndexes(n);
        default:
          return [];
      }
    });
  }
  interpretFields(e) {
    return e.flatMap((n) => this.interpretColumn(n));
  }
  interpretColumn(e) {
    var r, c, f, p, h, d, N, L, v;
    const n = [], s = {};
    s.name = X(e.callee).unwrap();
    const i = zt(e.args[0]);
    s.type = i.getValue(), n.push(...i.getErrors()), s.token = _(e), s.inline_refs = [];
    const a = e.args.slice(1);
    if (g.last(a) instanceof M) {
      const A = F(a.pop()).getValue();
      s.pk = !!((r = A[E.PK]) != null && r.length) || !!((c = A[E.PKey]) != null && c.length), s.increment = !!((f = A[E.Increment]) != null && f.length), s.unique = !!((p = A[E.Unique]) != null && p.length), s.not_null = (h = A[E.NotNull]) != null && h.length ? !0 : (d = A[E.Null]) != null && d.length ? !1 : void 0, s.dbdefault = Ht((L = (N = A[E.Default]) == null ? void 0 : N.at(0)) == null ? void 0 : L.value);
      const S = (v = A[E.Note]) == null ? void 0 : v.at(0);
      s.note = S && {
        value: V(S.value).map(ae).unwrap(),
        token: _(S)
      };
      const Te = A[E.Ref] || [];
      s.inline_refs = Te.flatMap((D) => {
        const [Ue] = je(D.value.expression);
        if (ht(Ue, e.symbol))
          return n.push(new l(o.SAME_ENDPOINT, "Two endpoints are the same", D)), [];
        const pe = D.value.op, B = q(D.value.expression).unwrap();
        let te;
        if (B.length === 2) {
          const [de, H] = B;
          te = {
            schemaName: null,
            tableName: de,
            fieldNames: [H],
            relation: pe.value,
            token: _(D)
          };
        } else if (B.length === 3) {
          const [de, H, Ee] = B;
          te = {
            schemaName: de,
            tableName: H,
            fieldNames: [Ee],
            relation: pe.value,
            token: _(D)
          };
        } else {
          n.push(new l(o.UNSUPPORTED, "Unsupported", D));
          const de = B.pop(), H = B.pop();
          te = {
            schemaName: B.join("."),
            tableName: H,
            fieldNames: [de],
            relation: pe.value,
            token: _(D)
          };
        }
        return te;
      });
    }
    return s.pk || (s.pk = a.some((A) => W(A).unwrap().toLowerCase() === "pk")), s.unique || (s.unique = a.some((A) => W(A).unwrap().toLowerCase() === "unique")), this.tablePartial.fields.push(s), s.pk && this.pkColumns.push(s), n;
  }
  interpretIndexes(e) {
    return this.tablePartial.indexes.push(...e.body.body.map((n) => {
      var r, c, f, p, h, d, N;
      const s = { columns: [] }, i = n;
      s.token = _(i);
      const a = [i.callee, ...i.args];
      if (g.last(a) instanceof M) {
        const L = F(a.pop()).getValue();
        s.pk = !!((r = L[E.PK]) != null && r.length), s.unique = !!((c = L[E.Unique]) != null && c.length), s.name = V((p = (f = L[E.Name]) == null ? void 0 : f.at(0)) == null ? void 0 : p.value).unwrap_or(void 0);
        const v = (h = L[E.Note]) == null ? void 0 : h.at(0);
        s.note = v && {
          value: V(v.value).unwrap(),
          token: _(v)
        }, s.type = W((N = (d = L[E.Type]) == null ? void 0 : d.at(0)) == null ? void 0 : N.value).unwrap_or(void 0);
      }
      return a.flatMap((L) => {
        if (!(L instanceof ee)) return L;
        const v = [];
        let A = L;
        for (; A instanceof ee; )
          v.push(A.argumentList), A = A.callee;
        return v.push(A), v;
      }).forEach((L) => {
        const { functional: v, nonFunctional: A } = $e(L).unwrap();
        s.columns.push(
          ...v.map((S) => ({
            value: S.value.value,
            type: "expression",
            token: _(S)
          })),
          ...A.map((S) => ({
            value: X(S).unwrap(),
            type: "column",
            token: _(S)
          }))
        );
      }), s;
    })), [];
  }
}
class Ts {
  constructor(e, n) {
    this.declarationNode = e, this.env = n, this.project = { enums: [], refs: [], tableGroups: [], tables: [], tablePartials: [] };
  }
  interpret() {
    return this.env.project.set(this.declarationNode, this.project), this.project.token = _(this.declarationNode), [...this.interpretName(this.declarationNode.name), ...this.interpretBody(this.declarationNode.body)];
  }
  interpretName(e) {
    if (!e)
      return this.project.name = null, [];
    const { name: n } = ge(e);
    return this.project.name = n, [];
  }
  interpretBody(e) {
    return e.body.flatMap((n) => {
      var i;
      const s = n;
      switch ((i = s.type) == null ? void 0 : i.value.toLowerCase()) {
        case "table": {
          const a = new Qt(s, this.env).interpret();
          return this.project.tables.push(this.env.tables.get(s)), a;
        }
        case "ref": {
          const a = new Jt(s, this.env).interpret();
          return this.project.refs.push(this.env.ref.get(s)), a;
        }
        case "tablegroup": {
          const a = new Kt(s, this.env).interpret();
          return this.project.tableGroups.push(this.env.tableGroups.get(s)), a;
        }
        case "enum": {
          const a = new Zt(s, this.env).interpret();
          return this.project.enums.push(this.env.enums.get(s)), a;
        }
        case "note":
          return this.project.note = {
            value: V(s.body instanceof oe ? s.body.body[0].callee : s.body.callee).map(ae).unwrap(),
            token: _(s)
          }, [];
        case "tablepartial": {
          const a = new en(s, this.env).interpret();
          return this.project.tablePartials.push(this.env.tablePartials.get(s)), a;
        }
        default:
          return this.project[s.type.value.toLowerCase()] = V(s.body.callee).unwrap(), [];
      }
    });
  }
}
function ms(t) {
  return {
    schemas: [],
    tables: Array.from(t.tables.values()),
    notes: Array.from(t.notes.values()),
    refs: Array.from(t.ref.values()),
    enums: Array.from(t.enums.values()),
    tableGroups: Array.from(t.tableGroups.values()),
    aliases: t.aliases,
    project: Array.from(t.project.values())[0] || {},
    tablePartials: Array.from(t.tablePartials.values())
  };
}
class bs {
  constructor(e) {
    this.ast = e, this.env = {
      schema: [],
      tables: /* @__PURE__ */ new Map(),
      notes: /* @__PURE__ */ new Map(),
      refIds: {},
      ref: /* @__PURE__ */ new Map(),
      enums: /* @__PURE__ */ new Map(),
      tableGroups: /* @__PURE__ */ new Map(),
      groupOfTable: {},
      aliases: [],
      project: /* @__PURE__ */ new Map(),
      tablePartials: /* @__PURE__ */ new Map()
    };
  }
  interpret() {
    const e = this.ast.body.flatMap((n) => {
      switch (Le(n).unwrap_or(void 0)) {
        case I.Table:
          return new Qt(n, this.env).interpret();
        case I.Note:
          return new Ns(n, this.env).interpret();
        case I.Ref:
          return new Jt(n, this.env).interpret();
        case I.TableGroup:
          return new Kt(n, this.env).interpret();
        case I.TablePartial:
          return new en(n, this.env).interpret();
        case I.Enum:
          return new Zt(n, this.env).interpret();
        case I.Project:
          return new Ts(n, this.env).interpret();
        default:
          return [];
      }
    });
    return new J(ms(this.env), e);
  }
}
var k = /* @__PURE__ */ ((t) => (t[t.Function = 1] = "Function", t[t.Constructor = 2] = "Constructor", t[t.Field = 3] = "Field", t[t.Variable = 4] = "Variable", t[t.Class = 5] = "Class", t[t.Struct = 6] = "Struct", t[t.Interface = 7] = "Interface", t[t.Module = 8] = "Module", t[t.Property = 9] = "Property", t[t.Event = 10] = "Event", t[t.Operator = 11] = "Operator", t[t.Unit = 12] = "Unit", t[t.Value = 13] = "Value", t[t.Constant = 14] = "Constant", t[t.Enum = 15] = "Enum", t[t.EnumMember = 16] = "EnumMember", t[t.Keyword = 17] = "Keyword", t[t.Text = 18] = "Text", t[t.Color = 19] = "Color", t[t.File = 20] = "File", t[t.Reference = 21] = "Reference", t[t.Customcolor = 22] = "Customcolor", t[t.Folder = 23] = "Folder", t[t.TypeParameter = 24] = "TypeParameter", t[t.User = 25] = "User", t[t.Issue = 26] = "Issue", t[t.Snippet = 27] = "Snippet", t))(k || {}), R = /* @__PURE__ */ ((t) => (t[t.None = 0] = "None", t[t.KeepWhitespace = 1] = "KeepWhitespace", t[t.InsertAsSnippet = 4] = "InsertAsSnippet", t))(R || {});
function xe(t) {
  switch (t) {
    case m.Schema:
      return k.Module;
    case m.Table:
    case m.TablePartial:
      return k.Class;
    case m.Column:
    case m.TableGroupField:
      return k.Field;
    case m.Enum:
      return k.Enum;
    case m.EnumField:
      return k.EnumMember;
    case m.TableGroup:
      return k.Struct;
    default:
      return k.Text;
  }
}
function We(t, e) {
  if (!t || Ze(t))
    return !1;
  for (const n of t.trailingTrivia) {
    if (n.start > e)
      break;
    if (n.kind === u.NEWLINE && n.end <= e)
      return !1;
  }
  return !0;
}
function G() {
  return {
    suggestions: []
  };
}
function Ye(t) {
  return {
    ...t,
    suggestions: t.suggestions.map((e) => ({
      ...e,
      insertText: ` ${e.insertText}`
    }))
  };
}
function Ke(t) {
  return {
    ...t,
    suggestions: t.suggestions.map((e) => ({
      ...e,
      insertText: e.insertText.split("").every(ze) ? e.insertText : `"${e.insertText}"`
    }))
  };
}
function ft(t, e) {
  return t.getOffsetAt(e);
}
class tn {
  constructor(e, n = []) {
    this.compiler = e, this.triggerCharacters = n;
  }
  provideCompletionItems(e, n) {
    var h, d;
    const s = ft(e, n), i = this.compiler.token.flatStream(), { token: a, index: r } = this.compiler.container.token(s), c = r === void 0 ? i[0] : i[r + 1];
    if ([
      ...(a == null ? void 0 : a.trailingTrivia) || [],
      ...(a == null ? void 0 : a.leadingTrivia) || [],
      ...(c == null ? void 0 : c.leadingTrivia) || []
    ].find((N) => fn(N) && Se(s, N)))
      return G();
    if (r === void 0)
      return kt();
    if ([u.STRING_LITERAL, u.QUOTED_STRING].includes(a.kind) && Se(s, a))
      return G();
    const f = this.compiler.container.element(s);
    if (this.compiler.container.scopeKind(s) === O.TOPLEVEL || f instanceof y && f.type && f.type.start <= s && f.type.end >= s)
      return kt();
    const p = [...this.compiler.container.stack(s)].reverse();
    for (const N of p)
      if (N instanceof Z)
        switch ((h = N.op) == null ? void 0 : h.value) {
          case ">":
          case "<":
          case "<>":
          case "-":
            return gt(
              this.compiler,
              s,
              N
            );
        }
      else if (N instanceof le)
        switch ((d = N.op) == null ? void 0 : d.value) {
          case ">":
          case "<":
          case "<>":
          case "-":
            return gt(
              this.compiler,
              s,
              N
            );
          case ".":
            return nn(
              this.compiler,
              s,
              N
            );
        }
      else {
        if (N instanceof se)
          return vt(this.compiler, s, N);
        if (N instanceof M)
          return vt(this.compiler, s, N);
        if (N instanceof ce)
          return Ls(this.compiler, s);
        if (N instanceof be)
          return Is(this.compiler, s);
        if (N instanceof w)
          return yt(this.compiler, s, N);
        if (N instanceof y && (N.bodyColon && s >= N.bodyColon.end || N.body && Se(s, N.body)))
          return yt(this.compiler, s, void 0);
      }
    return G();
  }
}
function Is(t, e) {
  const n = t.container.element(e);
  return Re(t, e, n, [m.TablePartial]);
}
function gt(t, e, n) {
  const s = t.container.scopeKind(e);
  if ([
    O.REF,
    O.TABLE,
    O.TABLEPARTIAL
  ].includes(s)) {
    const i = Re(t, e, t.container.element(e), [
      m.Table,
      m.Schema,
      m.Column
    ]);
    return We(n.op, e) ? Ye(i) : i;
  }
  return G();
}
function Re(t, e, n, s) {
  var r;
  if (n === void 0)
    return G();
  let i = n;
  const a = { suggestions: [] };
  for (; i; ) {
    if ((r = i == null ? void 0 : i.symbol) != null && r.symbolTable) {
      const { symbol: c } = i;
      a.suggestions.push(
        ...t.symbol.members(c).filter(({ kind: f }) => s.includes(f)).map(({ name: f, kind: p }) => ({
          label: f,
          insertText: f,
          insertTextRules: R.KeepWhitespace,
          kind: xe(p),
          sortText: xe(p).toString().padStart(2, "0"),
          range: void 0
        }))
      );
    }
    i = i instanceof y ? i.parent : void 0;
  }
  return Ke(a);
}
function Ls(t, e) {
  var s;
  switch (t.container.scopeKind(e)) {
    case O.INDEXES:
      return an(t, e);
    case O.REF:
      {
        const i = [...t.container.stack(e)];
        for (; i.length > 0; ) {
          const a = i.pop();
          if (a instanceof le && ((s = a.op) == null ? void 0 : s.value) === ".")
            return nn(
              t,
              e,
              a
            );
        }
      }
      return sn(t, e);
  }
  return G();
}
function vt(t, e, n) {
  const { token: s } = t.container.token(e);
  if ([u.COMMA, u.LBRACKET].includes(s == null ? void 0 : s.kind)) {
    const i = wt(t, e);
    return (s == null ? void 0 : s.kind) === u.COMMA && We(s, e) ? Ye(i) : i;
  }
  if (n.name && n.name.start <= e && n.name.end >= e)
    return wt(t, e);
  if (n.name instanceof ne) {
    const i = As(
      t,
      e,
      we(n.name).unwrap_or("")
    );
    return (s == null ? void 0 : s.kind) === u.COLON && We(s, e) ? Ye(i) : i;
  }
  return G();
}
function wt(t, e) {
  const n = t.container.element(e);
  if (n instanceof K) return G();
  const s = t.container.scopeKind(e);
  if (n.body && !Se(e, n.body)) {
    let i;
    switch (s) {
      case O.TABLE:
      case O.TABLEPARTIAL:
        i = [E.HeaderColor, E.Note];
        break;
      case O.TABLEGROUP:
        i = [E.Color, E.Note];
        break;
      default:
        i = [];
    }
    return {
      suggestions: i.map((a) => ({
        label: a,
        insertText: `${a}: `,
        kind: k.Field,
        insertTextRules: R.KeepWhitespace,
        range: void 0
      }))
    };
  }
  switch (s) {
    case O.TABLE:
    case O.TABLEPARTIAL:
      return {
        suggestions: [
          ...[
            E.PK,
            E.PKey,
            E.Null,
            E.NotNull,
            E.Increment,
            E.Unique
          ].map((i) => ({
            label: i,
            insertText: i,
            kind: k.Property,
            insertTextRules: R.KeepWhitespace,
            range: void 0
          })),
          ...[E.Ref, E.Default, E.Note].map((i) => ({
            label: i,
            insertText: `${i}: `,
            kind: k.Property,
            insertTextRules: R.KeepWhitespace,
            range: void 0
          }))
        ]
      };
    case O.ENUM:
      return {
        suggestions: [
          ...[E.Note].map((i) => ({
            label: i,
            insertText: `${i}: `,
            kind: k.Property,
            insertTextRules: R.KeepWhitespace,
            range: void 0
          }))
        ]
      };
    case O.INDEXES:
      return {
        suggestions: [
          ...[E.Unique, E.PK].map((i) => ({
            label: i,
            insertText: i,
            insertTextRules: R.KeepWhitespace,
            kind: k.Property,
            range: void 0
          })),
          ...[E.Note, E.Name, E.Type].map((i) => ({
            label: i,
            insertText: `${i}: `,
            kind: k.Property,
            insertTextRules: R.KeepWhitespace,
            range: void 0
          }))
        ]
      };
    case O.REF:
      return {
        suggestions: [
          E.Update,
          E.Delete,
          E.Color
        ].map((i) => ({
          label: i,
          insertText: `${i}: `,
          kind: k.Property,
          insertTextRules: R.KeepWhitespace,
          range: void 0
        }))
      };
  }
  return G();
}
function As(t, e, n) {
  switch (n == null ? void 0 : n.toLowerCase()) {
    case "update":
    case "delete":
      return {
        suggestions: ["cascade", "set default", "set null", "restrict"].map((s) => ({
          label: s,
          insertText: s,
          kind: k.Value,
          insertTextRules: R.KeepWhitespace,
          range: void 0
        }))
      };
    case "type":
      return {
        suggestions: ["btree", "hash"].map((s) => ({
          label: s,
          insertText: `${s}`,
          kind: k.Value,
          insertTextRules: R.KeepWhitespace,
          range: void 0
        }))
      };
  }
  return G();
}
function nn(t, e, n) {
  const s = _e(n).unwrap_or([]);
  if (s.pop(), s.some((a) => !$(a)))
    return G();
  const i = s.map((a) => W(a).unwrap());
  return Ke({
    suggestions: t.symbol.ofName({ nameStack: i, owner: t.container.element(e) }).flatMap(({ symbol: a }) => t.symbol.members(a)).map(({ kind: a, name: r }) => ({
      label: r,
      insertText: r,
      kind: xe(a),
      range: void 0
    }))
  });
}
function yt(t, e, n) {
  var i;
  switch (t.container.scopeKind(e)) {
    case O.TABLE:
    case O.TABLEPARTIAL:
      return gs(t, e, n);
    case O.PROJECT:
      return vs(t, e, n);
    case O.INDEXES:
      return ys(t, e);
    case O.ENUM:
      return _s(t, e, n);
    case O.REF: {
      const a = sn(t, e);
      return ((i = t.container.token(e).token) == null ? void 0 : i.kind) === u.COLON && We(t.container.token(e).token, e) ? Ye(a) : a;
    }
    case O.TABLEGROUP:
      return ws(t);
    default:
      return G();
  }
}
function kt() {
  return {
    suggestions: ["Table", "TableGroup", "Enum", "Project", "Ref", "TablePartial"].map((t) => ({
      label: t,
      insertText: t,
      insertTextRules: R.KeepWhitespace,
      kind: k.Keyword,
      range: void 0
    }))
  };
}
function _s(t, e, n) {
  return n != null && n.callee && pt(e, n) === 1 ? Re(t, e, t.container.element(e), [
    m.Schema,
    m.Table,
    m.Column
  ]) : G();
}
function gs(t, e, n) {
  const s = ["Note", "indexes"];
  if (!(n != null && n.callee))
    return {
      suggestions: s.map((a) => ({
        label: a,
        insertText: a,
        insertTextRules: R.KeepWhitespace,
        kind: k.Keyword,
        range: void 0
      }))
    };
  const i = pt(e, n);
  return i === 0 ? {
    suggestions: s.map((a) => ({
      label: a,
      insertText: a,
      insertTextRules: R.KeepWhitespace,
      kind: k.Keyword,
      range: void 0
    }))
  } : i === 1 ? ks(t, e) : G();
}
function vs(t, e, n) {
  const s = ["Table", "TableGroup", "Enum", "Note", "Ref", "TablePartial"];
  return n != null && n.callee ? pt(e, n) === 0 ? {
    suggestions: s.map((a) => ({
      label: a,
      insertText: a,
      insertTextRules: R.KeepWhitespace,
      kind: k.Keyword,
      range: void 0
    }))
  } : G() : {
    suggestions: s.map((a) => ({
      label: a,
      insertText: a,
      insertTextRules: R.KeepWhitespace,
      kind: k.Keyword,
      range: void 0
    }))
  };
}
function sn(t, e) {
  return Re(t, e, t.container.element(e), [
    m.Schema,
    m.Table,
    m.Column
  ]);
}
function ws(t) {
  return {
    suggestions: [
      ...Ke({
        suggestions: [...t.parse.publicSymbolTable().entries()].flatMap(([e]) => {
          const n = ie(e).unwrap_or(void 0);
          if (n === void 0) return [];
          const { kind: s, name: i } = n;
          return s !== m.Table && s !== m.Schema ? [] : {
            label: i,
            insertText: i,
            insertTextRules: R.KeepWhitespace,
            kind: xe(s),
            range: void 0
          };
        })
      }).suggestions,
      ...["Note"].map((e) => ({
        label: e,
        insertText: e,
        insertTextRules: R.KeepWhitespace,
        kind: k.Keyword,
        range: void 0
      }))
    ]
  };
}
function ys(t, e) {
  return an(t, e);
}
function ks(t, e) {
  return {
    suggestions: [
      ...[
        "integer",
        "int",
        "tinyint",
        "smallint",
        "mediumint",
        "bigint",
        "bit",
        "bool",
        "binary",
        "varbinary",
        "logical",
        "char",
        "nchar",
        "varchar",
        "varchar2",
        "nvarchar",
        "nvarchar2",
        "binary_float",
        "binary_double",
        "float",
        "double",
        "decimal",
        "dec",
        "real",
        "money",
        "smallmoney",
        "enum",
        "tinyblob",
        "tinytext",
        "blob",
        "text",
        "mediumblob",
        "mediumtext",
        "longblob",
        "longtext",
        "ntext",
        "set",
        "inet6",
        "uuid",
        "image",
        "date",
        "time",
        "datetime",
        "datetime2",
        "timestamp",
        "year",
        "smalldatetime",
        "datetimeoffset",
        "XML",
        "sql_variant",
        "uniqueidentifier",
        "CURSOR",
        "BFILE",
        "CLOB",
        "NCLOB",
        "RAW"
      ].map((n) => ({
        label: n,
        insertText: n,
        insertTextRules: R.KeepWhitespace,
        kind: k.TypeParameter,
        sortText: k.TypeParameter.toString().padStart(2, "0"),
        range: void 0
      })),
      ...Re(t, e, t.container.element(e), [
        m.Enum,
        m.Schema
      ]).suggestions
    ]
  };
}
function an(t, e) {
  const n = t.container.element(e), s = n == null ? void 0 : n.parent;
  if (!((s == null ? void 0 : s.symbol) instanceof Mt))
    return G();
  const { symbolTable: i } = s.symbol;
  return Ke({
    suggestions: [...i.entries()].flatMap(([a]) => {
      const r = ie(a).unwrap_or(void 0);
      if (r === void 0)
        return [];
      const { name: c } = r;
      return {
        label: c,
        insertText: c,
        insertTextRules: R.KeepWhitespace,
        kind: xe(m.Column),
        range: void 0
      };
    })
  });
}
function pt(t, e) {
  if (!e.callee) return -1;
  const n = [e.callee, ...e.args], s = n.findIndex((i) => t <= i.end);
  return s === -1 ? n.length : s;
}
class rn {
  constructor(e) {
    this.compiler = e;
  }
  provideDefinition(e, n) {
    var r, c;
    const { uri: s } = e, i = ft(e, n), a = [...this.compiler.container.stack(i)];
    for (; a.length !== 0; ) {
      const f = a.pop();
      if (!(f != null && f.referee)) continue;
      let p;
      if ((r = f.referee) != null && r.declaration && [
        me.PRIMARY_EXPRESSION,
        me.VARIABLE,
        me.PARTIAL_INJECTION
      ].includes(f == null ? void 0 : f.kind) ? { declaration: p } = f.referee : (c = f.referee) != null && c.injectorDeclaration && (p = f.referee.injectorDeclaration), p) {
        const { startPos: h, endPos: d } = p;
        return [
          {
            range: {
              startColumn: h.column + 1,
              startLineNumber: h.line + 1,
              endColumn: d.column + 1,
              endLineNumber: d.line + 1
            },
            uri: s
          }
        ];
      }
    }
    return [];
  }
}
class on {
  constructor(e) {
    this.compiler = e;
  }
  provideReferences(e, n) {
    const { uri: s } = e, i = ft(e, n), a = [...this.compiler.container.stack(i)];
    for (; a.length !== 0; ) {
      const r = a.pop();
      if (r && [
        me.ELEMENT_DECLARATION,
        me.FUNCTION_APPLICATION,
        me.PRIMARY_EXPRESSION
      ].includes(r == null ? void 0 : r.kind)) {
        const { symbol: c } = r;
        if (c != null && c.references.length)
          return c.references.map(({ startPos: f, endPos: p }) => ({
            range: {
              startColumn: f.column + 1,
              startLineNumber: f.line + 1,
              endColumn: p.column + 1,
              endLineNumber: p.line + 1
            },
            uri: s
          }));
      }
    }
    return [];
  }
}
const Ds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompletionItemInsertTextRule: R,
  CompletionItemKind: k,
  DBMLCompletionItemProvider: tn,
  DBMLDefinitionProvider: rn,
  DBMLReferencesProvider: on
}, Symbol.toStringTag, { value: "Module" }));
var O = /* @__PURE__ */ ((t) => (t[t.TABLE = 0] = "TABLE", t[t.ENUM = 1] = "ENUM", t[t.TABLEGROUP = 2] = "TABLEGROUP", t[t.INDEXES = 3] = "INDEXES", t[t.NOTE = 4] = "NOTE", t[t.REF = 5] = "REF", t[t.PROJECT = 6] = "PROJECT", t[t.CUSTOM = 7] = "CUSTOM", t[t.TOPLEVEL = 8] = "TOPLEVEL", t[t.TABLEPARTIAL = 9] = "TABLEPARTIAL", t))(O || {});
class xs {
  constructor() {
    this.source = "", this.cache = new Array(
      16
      /* TOTAL_QUERY_COUNT */
    ).fill(null), this.nodeIdGenerator = new pn(), this.symbolIdGenerator = new mn(), this.token = {
      invalidStream: this.createQuery(
        6,
        () => this.parse.tokens().filter(Bt)
      ),
      // Valid + Invalid tokens (which are guarenteed to be non-trivials) are included in the stream
      flatStream: this.createQuery(
        7,
        () => this.parse.tokens().flatMap((e) => [...e.leadingInvalid, e, ...e.trailingInvalid])
      )
    }, this.parse = {
      source: () => this.source,
      _: this.createQuery(
        0,
        () => {
          const e = new On(this.source).lex().chain((n) => new Mn(n, this.nodeIdGenerator).parse()).chain(({ ast: n, tokens: s }) => new Es(n, this.symbolIdGenerator).analyze().map(() => ({ ast: n, tokens: s })));
          return e.getErrors().length > 0 ? e : e.chain(({ ast: n, tokens: s }) => new bs(n).interpret().map((a) => ({ ast: n, tokens: s, rawDb: a })));
        }
      ),
      ast: this.createQuery(
        1,
        () => this.parse._().getValue().ast
      ),
      errors: this.createQuery(2, () => this.parse._().getErrors()),
      tokens: this.createQuery(
        4,
        () => this.parse._().getValue().tokens
      ),
      rawDb: this.createQuery(
        3,
        () => this.parse._().getValue().rawDb
      ),
      publicSymbolTable: this.createQuery(
        5,
        () => this.parse._().getValue().ast.symbol.symbolTable
      )
    }, this.container = {
      stack: this.createQuery(
        10,
        (e) => {
          const n = this.token.flatStream(), { index: s, token: i } = this.container.token(e), a = s === void 0 ? -1 : cn(n, (p) => !p.isInvalid, s);
          if (a === -1)
            return [this.parse.ast()];
          const r = n[a].start;
          let c = this.parse.ast();
          const f = [c];
          for (; ; ) {
            const h = xn(c).find((d) => Se(r, d));
            if (h === void 0 || h instanceof Q)
              break;
            f.push(h), c = h;
          }
          if ((i == null ? void 0 : i.kind) === u.COLON)
            return f;
          for (; f.length > 0; ) {
            let p = !1;
            const h = Ve(f);
            if (h instanceof w) {
              const d = this.parse.source();
              for (let N = h.end; N < e; N += 1)
                d[N] === `
` && (f.pop(), p = !0);
            } else h instanceof Z || h instanceof le ? this.container.token(e).token !== h.op && (f.pop(), p = !0) : h instanceof M ? h.listCloseBracket && h.end <= e && (f.pop(), p = !0) : h instanceof ce ? h.tupleCloseParen && h.end <= e && (f.pop(), p = !0) : h instanceof oe ? h.blockCloseBrace && h.end <= e && (f.pop(), p = !0) : h instanceof ne || h.end < e && (f.pop(), p = !0);
            if (p) {
              const d = Ve(f);
              d instanceof y && d.end <= e && f.pop();
            }
            if (!p)
              break;
          }
          return f;
        }
      ),
      token: this.createQuery(
        11,
        (e) => {
          const n = this.token.flatStream().findIndex((s) => s.start >= e);
          return n === void 0 ? { token: void 0, index: void 0 } : n <= 0 ? { token: void 0, index: void 0 } : {
            token: this.token.flatStream()[n - 1],
            index: n - 1
          };
        }
      ),
      element: this.createQuery(
        12,
        (e) => {
          const n = this.container.stack(e);
          for (let s = n.length - 1; s >= 0; s -= 1)
            if (n[s] instanceof y)
              return n[s];
          return this.parse.ast();
        }
      ),
      scope: this.createQuery(
        14,
        (e) => {
          var n, s;
          return (s = (n = this.container.element(e)) == null ? void 0 : n.symbol) == null ? void 0 : s.symbolTable;
        }
      ),
      scopeKind: this.createQuery(15, (e) => {
        var s;
        if (this.container.element(e) instanceof K)
          return 8;
        switch ((s = this.container.element(e).type) == null ? void 0 : s.value.toLowerCase()) {
          case "table":
            return 0;
          case "enum":
            return 1;
          case "ref":
            return 5;
          case "tablegroup":
            return 2;
          case "indexes":
            return 3;
          case "note":
            return 4;
          case "project":
            return 6;
          case "tablepartial":
            return 9;
          default:
            return 7;
        }
      })
    }, this.symbol = {
      // Given a stack of name and the current scope
      // Try looking up the first name in the stack in the current scope
      // and resolve the rest of the name stack as members
      // Then try to do the same with all ancestor scopes
      ofName: this.createQuery(
        8,
        ({
          nameStack: e,
          owner: n = this.parse.ast()
        }) => {
          var i;
          if (e.length === 0)
            return [];
          const s = [];
          for (let a = n; a; a = a instanceof y ? a.parent : void 0) {
            if (!((i = a.symbol) != null && i.symbolTable))
              continue;
            const { symbolTable: r } = a.symbol;
            let c = [r], f = [];
            for (const p of e)
              f = c.flatMap(
                (h) => wn(p).flatMap((d) => {
                  const N = h.get(d), L = ie(d).unwrap_or(void 0);
                  return !N || !L ? [] : { ...L, symbol: N };
                })
              ), c = f.flatMap(
                (h) => h.symbol.symbolTable ? h.symbol.symbolTable : []
              );
            s.push(...f);
          }
          return s;
        },
        ({ nameStack: e, owner: n }) => `${e.join(".")}@${n.id}`
      ),
      members: this.createQuery(
        9,
        (e) => e.symbolTable ? [...e.symbolTable.entries()].map(([n, s]) => ({
          ...ie(n).unwrap(),
          symbol: s
        })) : []
      )
    };
  }
  createQuery(e, n, s) {
    return (i) => {
      const a = this.cache[e], r = i && s ? s(i) : i;
      if (a !== null) {
        if (!(a instanceof Map))
          return a;
        if (a.has(r))
          return a.get(r);
      }
      const c = n(i);
      return i !== void 0 ? a instanceof Map ? a.set(r, c) : (this.cache[e] = /* @__PURE__ */ new Map(), this.cache[e].set(r, c)) : this.cache[e] = c, c;
    };
  }
  setSource(e) {
    this.source = e, this.cache = new Array(
      16
      /* TOTAL_QUERY_COUNT */
    ).fill(null), this.nodeIdGenerator.reset(), this.symbolIdGenerator.reset();
  }
  initMonacoServices() {
    return {
      definitionProvider: new rn(this),
      referenceProvider: new on(this),
      autocompletionProvider: new tn(this)
    };
  }
}
export {
  xs as Compiler,
  Ss as serialize,
  Ds as services
};
